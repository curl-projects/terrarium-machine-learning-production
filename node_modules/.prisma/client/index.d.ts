
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model DiscordMessage
 * 
 */
export type DiscordMessage = {
  id: number
  threadId: string
  messageUser: string
  messageContent: string
}

/**
 * Model DiscordUser
 * 
 */
export type DiscordUser = {
  username: string
  notionAuthId: string
}

/**
 * Model Feature
 * 
 */
export type Feature = {
  id: number
  title: string
  description: string
  userId: string
  columnState: number
  rankState: number
  isSearched: boolean
}

/**
 * Model FeatureRequest
 * 
 */
export type FeatureRequest = {
  fr_id: string
  message_id: string
  message: string
  created_at: string
  author: string
  label: string
  fr: string
  kmeans_labels: number
  userId: string
}

/**
 * Model FeatureRequestMap
 * 
 */
export type FeatureRequestMap = {
  featureId: number
  featureRequestId: string
  pinned: boolean
  cluster: number
}

/**
 * Model NotionAuth
 * 
 */
export type NotionAuth = {
  botId: string
  accessToken: string
  owner: string
  duplicatedTemplateId: string
  workspaceIcon: string
  workspaceId: string
  workspaceName: string
  userId: string
  guildName: string | null
}

/**
 * Model Thread
 * 
 */
export type Thread = {
  ticketNumber: string
  threadName: string
  createdTime: string
  threadLink: string
  bugOverview: string
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string
  discordBotAuth: boolean
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more DiscordMessages
 * const discordMessages = await prisma.discordMessage.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more DiscordMessages
   * const discordMessages = await prisma.discordMessage.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.discordMessage`: Exposes CRUD operations for the **DiscordMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscordMessages
    * const discordMessages = await prisma.discordMessage.findMany()
    * ```
    */
  get discordMessage(): Prisma.DiscordMessageDelegate<GlobalReject>;

  /**
   * `prisma.discordUser`: Exposes CRUD operations for the **DiscordUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscordUsers
    * const discordUsers = await prisma.discordUser.findMany()
    * ```
    */
  get discordUser(): Prisma.DiscordUserDelegate<GlobalReject>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<GlobalReject>;

  /**
   * `prisma.featureRequest`: Exposes CRUD operations for the **FeatureRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureRequests
    * const featureRequests = await prisma.featureRequest.findMany()
    * ```
    */
  get featureRequest(): Prisma.FeatureRequestDelegate<GlobalReject>;

  /**
   * `prisma.featureRequestMap`: Exposes CRUD operations for the **FeatureRequestMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureRequestMaps
    * const featureRequestMaps = await prisma.featureRequestMap.findMany()
    * ```
    */
  get featureRequestMap(): Prisma.FeatureRequestMapDelegate<GlobalReject>;

  /**
   * `prisma.notionAuth`: Exposes CRUD operations for the **NotionAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotionAuths
    * const notionAuths = await prisma.notionAuth.findMany()
    * ```
    */
  get notionAuth(): Prisma.NotionAuthDelegate<GlobalReject>;

  /**
   * `prisma.thread`: Exposes CRUD operations for the **Thread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads
    * const threads = await prisma.thread.findMany()
    * ```
    */
  get thread(): Prisma.ThreadDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.13.0
   * Query Engine version: efdf9b1183dddfd4258cd181a72125755215ab7b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    DiscordMessage: 'DiscordMessage',
    DiscordUser: 'DiscordUser',
    Feature: 'Feature',
    FeatureRequest: 'FeatureRequest',
    FeatureRequestMap: 'FeatureRequestMap',
    NotionAuth: 'NotionAuth',
    Thread: 'Thread',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FeatureCountOutputType
   */


  export type FeatureCountOutputType = {
    FeatureRequestMap: number
  }

  export type FeatureCountOutputTypeSelect = {
    FeatureRequestMap?: boolean
  }

  export type FeatureCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FeatureCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FeatureCountOutputType
    : S extends undefined
    ? never
    : S extends FeatureCountOutputTypeArgs
    ?'include' extends U
    ? FeatureCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FeatureCountOutputType ? FeatureCountOutputType[P] : never
  } 
    : FeatureCountOutputType
  : FeatureCountOutputType




  // Custom InputTypes

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FeatureCountOutputType
     * 
    **/
    select?: FeatureCountOutputTypeSelect | null
  }



  /**
   * Count Type FeatureRequestCountOutputType
   */


  export type FeatureRequestCountOutputType = {
    FeatureRequestMap: number
  }

  export type FeatureRequestCountOutputTypeSelect = {
    FeatureRequestMap?: boolean
  }

  export type FeatureRequestCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FeatureRequestCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FeatureRequestCountOutputType
    : S extends undefined
    ? never
    : S extends FeatureRequestCountOutputTypeArgs
    ?'include' extends U
    ? FeatureRequestCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FeatureRequestCountOutputType ? FeatureRequestCountOutputType[P] : never
  } 
    : FeatureRequestCountOutputType
  : FeatureRequestCountOutputType




  // Custom InputTypes

  /**
   * FeatureRequestCountOutputType without action
   */
  export type FeatureRequestCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestCountOutputType
     * 
    **/
    select?: FeatureRequestCountOutputTypeSelect | null
  }



  /**
   * Count Type NotionAuthCountOutputType
   */


  export type NotionAuthCountOutputType = {
    DiscordUser: number
  }

  export type NotionAuthCountOutputTypeSelect = {
    DiscordUser?: boolean
  }

  export type NotionAuthCountOutputTypeGetPayload<
    S extends boolean | null | undefined | NotionAuthCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? NotionAuthCountOutputType
    : S extends undefined
    ? never
    : S extends NotionAuthCountOutputTypeArgs
    ?'include' extends U
    ? NotionAuthCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof NotionAuthCountOutputType ? NotionAuthCountOutputType[P] : never
  } 
    : NotionAuthCountOutputType
  : NotionAuthCountOutputType




  // Custom InputTypes

  /**
   * NotionAuthCountOutputType without action
   */
  export type NotionAuthCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NotionAuthCountOutputType
     * 
    **/
    select?: NotionAuthCountOutputTypeSelect | null
  }



  /**
   * Count Type ThreadCountOutputType
   */


  export type ThreadCountOutputType = {
    DiscordMessage: number
  }

  export type ThreadCountOutputTypeSelect = {
    DiscordMessage?: boolean
  }

  export type ThreadCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ThreadCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ThreadCountOutputType
    : S extends undefined
    ? never
    : S extends ThreadCountOutputTypeArgs
    ?'include' extends U
    ? ThreadCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ThreadCountOutputType ? ThreadCountOutputType[P] : never
  } 
    : ThreadCountOutputType
  : ThreadCountOutputType




  // Custom InputTypes

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ThreadCountOutputType
     * 
    **/
    select?: ThreadCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Feature: number
    FeatureRequest: number
    NotionAuth: number
  }

  export type UserCountOutputTypeSelect = {
    Feature?: boolean
    FeatureRequest?: boolean
    NotionAuth?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model DiscordMessage
   */


  export type AggregateDiscordMessage = {
    _count: DiscordMessageCountAggregateOutputType | null
    _avg: DiscordMessageAvgAggregateOutputType | null
    _sum: DiscordMessageSumAggregateOutputType | null
    _min: DiscordMessageMinAggregateOutputType | null
    _max: DiscordMessageMaxAggregateOutputType | null
  }

  export type DiscordMessageAvgAggregateOutputType = {
    id: number | null
  }

  export type DiscordMessageSumAggregateOutputType = {
    id: number | null
  }

  export type DiscordMessageMinAggregateOutputType = {
    id: number | null
    threadId: string | null
    messageUser: string | null
    messageContent: string | null
  }

  export type DiscordMessageMaxAggregateOutputType = {
    id: number | null
    threadId: string | null
    messageUser: string | null
    messageContent: string | null
  }

  export type DiscordMessageCountAggregateOutputType = {
    id: number
    threadId: number
    messageUser: number
    messageContent: number
    _all: number
  }


  export type DiscordMessageAvgAggregateInputType = {
    id?: true
  }

  export type DiscordMessageSumAggregateInputType = {
    id?: true
  }

  export type DiscordMessageMinAggregateInputType = {
    id?: true
    threadId?: true
    messageUser?: true
    messageContent?: true
  }

  export type DiscordMessageMaxAggregateInputType = {
    id?: true
    threadId?: true
    messageUser?: true
    messageContent?: true
  }

  export type DiscordMessageCountAggregateInputType = {
    id?: true
    threadId?: true
    messageUser?: true
    messageContent?: true
    _all?: true
  }

  export type DiscordMessageAggregateArgs = {
    /**
     * Filter which DiscordMessage to aggregate.
     * 
    **/
    where?: DiscordMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscordMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscordMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscordMessages
    **/
    _count?: true | DiscordMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscordMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscordMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscordMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscordMessageMaxAggregateInputType
  }

  export type GetDiscordMessageAggregateType<T extends DiscordMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscordMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscordMessage[P]>
      : GetScalarType<T[P], AggregateDiscordMessage[P]>
  }




  export type DiscordMessageGroupByArgs = {
    where?: DiscordMessageWhereInput
    orderBy?: Enumerable<DiscordMessageOrderByWithAggregationInput>
    by: Array<DiscordMessageScalarFieldEnum>
    having?: DiscordMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscordMessageCountAggregateInputType | true
    _avg?: DiscordMessageAvgAggregateInputType
    _sum?: DiscordMessageSumAggregateInputType
    _min?: DiscordMessageMinAggregateInputType
    _max?: DiscordMessageMaxAggregateInputType
  }


  export type DiscordMessageGroupByOutputType = {
    id: number
    threadId: string
    messageUser: string
    messageContent: string
    _count: DiscordMessageCountAggregateOutputType | null
    _avg: DiscordMessageAvgAggregateOutputType | null
    _sum: DiscordMessageSumAggregateOutputType | null
    _min: DiscordMessageMinAggregateOutputType | null
    _max: DiscordMessageMaxAggregateOutputType | null
  }

  type GetDiscordMessageGroupByPayload<T extends DiscordMessageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscordMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscordMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscordMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DiscordMessageGroupByOutputType[P]>
        }
      >
    >


  export type DiscordMessageSelect = {
    id?: boolean
    threadId?: boolean
    messageUser?: boolean
    messageContent?: boolean
    Thread?: boolean | ThreadArgs
  }

  export type DiscordMessageInclude = {
    Thread?: boolean | ThreadArgs
  }

  export type DiscordMessageGetPayload<
    S extends boolean | null | undefined | DiscordMessageArgs,
    U = keyof S
      > = S extends true
        ? DiscordMessage
    : S extends undefined
    ? never
    : S extends DiscordMessageArgs | DiscordMessageFindManyArgs
    ?'include' extends U
    ? DiscordMessage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Thread' ? ThreadGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Thread' ? ThreadGetPayload<S['select'][P]> :  P extends keyof DiscordMessage ? DiscordMessage[P] : never
  } 
    : DiscordMessage
  : DiscordMessage


  type DiscordMessageCountArgs = Merge<
    Omit<DiscordMessageFindManyArgs, 'select' | 'include'> & {
      select?: DiscordMessageCountAggregateInputType | true
    }
  >

  export interface DiscordMessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DiscordMessage that matches the filter.
     * @param {DiscordMessageFindUniqueArgs} args - Arguments to find a DiscordMessage
     * @example
     * // Get one DiscordMessage
     * const discordMessage = await prisma.discordMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscordMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscordMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DiscordMessage'> extends True ? CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage>, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T>>> : CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage | null >, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T> | null >>

    /**
     * Find the first DiscordMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordMessageFindFirstArgs} args - Arguments to find a DiscordMessage
     * @example
     * // Get one DiscordMessage
     * const discordMessage = await prisma.discordMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscordMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscordMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DiscordMessage'> extends True ? CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage>, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T>>> : CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage | null >, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T> | null >>

    /**
     * Find zero or more DiscordMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscordMessages
     * const discordMessages = await prisma.discordMessage.findMany()
     * 
     * // Get first 10 DiscordMessages
     * const discordMessages = await prisma.discordMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discordMessageWithIdOnly = await prisma.discordMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscordMessageFindManyArgs>(
      args?: SelectSubset<T, DiscordMessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DiscordMessage>>, PrismaPromise<Array<DiscordMessageGetPayload<T>>>>

    /**
     * Create a DiscordMessage.
     * @param {DiscordMessageCreateArgs} args - Arguments to create a DiscordMessage.
     * @example
     * // Create one DiscordMessage
     * const DiscordMessage = await prisma.discordMessage.create({
     *   data: {
     *     // ... data to create a DiscordMessage
     *   }
     * })
     * 
    **/
    create<T extends DiscordMessageCreateArgs>(
      args: SelectSubset<T, DiscordMessageCreateArgs>
    ): CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage>, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T>>>

    /**
     * Create many DiscordMessages.
     *     @param {DiscordMessageCreateManyArgs} args - Arguments to create many DiscordMessages.
     *     @example
     *     // Create many DiscordMessages
     *     const discordMessage = await prisma.discordMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscordMessageCreateManyArgs>(
      args?: SelectSubset<T, DiscordMessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DiscordMessage.
     * @param {DiscordMessageDeleteArgs} args - Arguments to delete one DiscordMessage.
     * @example
     * // Delete one DiscordMessage
     * const DiscordMessage = await prisma.discordMessage.delete({
     *   where: {
     *     // ... filter to delete one DiscordMessage
     *   }
     * })
     * 
    **/
    delete<T extends DiscordMessageDeleteArgs>(
      args: SelectSubset<T, DiscordMessageDeleteArgs>
    ): CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage>, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T>>>

    /**
     * Update one DiscordMessage.
     * @param {DiscordMessageUpdateArgs} args - Arguments to update one DiscordMessage.
     * @example
     * // Update one DiscordMessage
     * const discordMessage = await prisma.discordMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscordMessageUpdateArgs>(
      args: SelectSubset<T, DiscordMessageUpdateArgs>
    ): CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage>, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T>>>

    /**
     * Delete zero or more DiscordMessages.
     * @param {DiscordMessageDeleteManyArgs} args - Arguments to filter DiscordMessages to delete.
     * @example
     * // Delete a few DiscordMessages
     * const { count } = await prisma.discordMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscordMessageDeleteManyArgs>(
      args?: SelectSubset<T, DiscordMessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscordMessages
     * const discordMessage = await prisma.discordMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscordMessageUpdateManyArgs>(
      args: SelectSubset<T, DiscordMessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscordMessage.
     * @param {DiscordMessageUpsertArgs} args - Arguments to update or create a DiscordMessage.
     * @example
     * // Update or create a DiscordMessage
     * const discordMessage = await prisma.discordMessage.upsert({
     *   create: {
     *     // ... data to create a DiscordMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscordMessage we want to update
     *   }
     * })
    **/
    upsert<T extends DiscordMessageUpsertArgs>(
      args: SelectSubset<T, DiscordMessageUpsertArgs>
    ): CheckSelect<T, Prisma__DiscordMessageClient<DiscordMessage>, Prisma__DiscordMessageClient<DiscordMessageGetPayload<T>>>

    /**
     * Count the number of DiscordMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordMessageCountArgs} args - Arguments to filter DiscordMessages to count.
     * @example
     * // Count the number of DiscordMessages
     * const count = await prisma.discordMessage.count({
     *   where: {
     *     // ... the filter for the DiscordMessages we want to count
     *   }
     * })
    **/
    count<T extends DiscordMessageCountArgs>(
      args?: Subset<T, DiscordMessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscordMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscordMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscordMessageAggregateArgs>(args: Subset<T, DiscordMessageAggregateArgs>): PrismaPromise<GetDiscordMessageAggregateType<T>>

    /**
     * Group by DiscordMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscordMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscordMessageGroupByArgs['orderBy'] }
        : { orderBy?: DiscordMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscordMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscordMessageGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscordMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscordMessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Thread<T extends ThreadArgs = {}>(args?: Subset<T, ThreadArgs>): CheckSelect<T, Prisma__ThreadClient<Thread | null >, Prisma__ThreadClient<ThreadGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DiscordMessage findUnique
   */
  export type DiscordMessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * Throw an Error if a DiscordMessage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscordMessage to fetch.
     * 
    **/
    where: DiscordMessageWhereUniqueInput
  }


  /**
   * DiscordMessage findFirst
   */
  export type DiscordMessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * Throw an Error if a DiscordMessage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscordMessage to fetch.
     * 
    **/
    where?: DiscordMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscordMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordMessages.
     * 
    **/
    cursor?: DiscordMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordMessages.
     * 
    **/
    distinct?: Enumerable<DiscordMessageScalarFieldEnum>
  }


  /**
   * DiscordMessage findMany
   */
  export type DiscordMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * Filter, which DiscordMessages to fetch.
     * 
    **/
    where?: DiscordMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscordMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscordMessages.
     * 
    **/
    cursor?: DiscordMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordMessages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscordMessageScalarFieldEnum>
  }


  /**
   * DiscordMessage create
   */
  export type DiscordMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * The data needed to create a DiscordMessage.
     * 
    **/
    data: XOR<DiscordMessageCreateInput, DiscordMessageUncheckedCreateInput>
  }


  /**
   * DiscordMessage createMany
   */
  export type DiscordMessageCreateManyArgs = {
    /**
     * The data used to create many DiscordMessages.
     * 
    **/
    data: Enumerable<DiscordMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DiscordMessage update
   */
  export type DiscordMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * The data needed to update a DiscordMessage.
     * 
    **/
    data: XOR<DiscordMessageUpdateInput, DiscordMessageUncheckedUpdateInput>
    /**
     * Choose, which DiscordMessage to update.
     * 
    **/
    where: DiscordMessageWhereUniqueInput
  }


  /**
   * DiscordMessage updateMany
   */
  export type DiscordMessageUpdateManyArgs = {
    /**
     * The data used to update DiscordMessages.
     * 
    **/
    data: XOR<DiscordMessageUpdateManyMutationInput, DiscordMessageUncheckedUpdateManyInput>
    /**
     * Filter which DiscordMessages to update
     * 
    **/
    where?: DiscordMessageWhereInput
  }


  /**
   * DiscordMessage upsert
   */
  export type DiscordMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * The filter to search for the DiscordMessage to update in case it exists.
     * 
    **/
    where: DiscordMessageWhereUniqueInput
    /**
     * In case the DiscordMessage found by the `where` argument doesn't exist, create a new DiscordMessage with this data.
     * 
    **/
    create: XOR<DiscordMessageCreateInput, DiscordMessageUncheckedCreateInput>
    /**
     * In case the DiscordMessage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscordMessageUpdateInput, DiscordMessageUncheckedUpdateInput>
  }


  /**
   * DiscordMessage delete
   */
  export type DiscordMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
    /**
     * Filter which DiscordMessage to delete.
     * 
    **/
    where: DiscordMessageWhereUniqueInput
  }


  /**
   * DiscordMessage deleteMany
   */
  export type DiscordMessageDeleteManyArgs = {
    /**
     * Filter which DiscordMessages to delete
     * 
    **/
    where?: DiscordMessageWhereInput
  }


  /**
   * DiscordMessage without action
   */
  export type DiscordMessageArgs = {
    /**
     * Select specific fields to fetch from the DiscordMessage
     * 
    **/
    select?: DiscordMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordMessageInclude | null
  }



  /**
   * Model DiscordUser
   */


  export type AggregateDiscordUser = {
    _count: DiscordUserCountAggregateOutputType | null
    _min: DiscordUserMinAggregateOutputType | null
    _max: DiscordUserMaxAggregateOutputType | null
  }

  export type DiscordUserMinAggregateOutputType = {
    username: string | null
    notionAuthId: string | null
  }

  export type DiscordUserMaxAggregateOutputType = {
    username: string | null
    notionAuthId: string | null
  }

  export type DiscordUserCountAggregateOutputType = {
    username: number
    notionAuthId: number
    _all: number
  }


  export type DiscordUserMinAggregateInputType = {
    username?: true
    notionAuthId?: true
  }

  export type DiscordUserMaxAggregateInputType = {
    username?: true
    notionAuthId?: true
  }

  export type DiscordUserCountAggregateInputType = {
    username?: true
    notionAuthId?: true
    _all?: true
  }

  export type DiscordUserAggregateArgs = {
    /**
     * Filter which DiscordUser to aggregate.
     * 
    **/
    where?: DiscordUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscordUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscordUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscordUsers
    **/
    _count?: true | DiscordUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscordUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscordUserMaxAggregateInputType
  }

  export type GetDiscordUserAggregateType<T extends DiscordUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscordUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscordUser[P]>
      : GetScalarType<T[P], AggregateDiscordUser[P]>
  }




  export type DiscordUserGroupByArgs = {
    where?: DiscordUserWhereInput
    orderBy?: Enumerable<DiscordUserOrderByWithAggregationInput>
    by: Array<DiscordUserScalarFieldEnum>
    having?: DiscordUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscordUserCountAggregateInputType | true
    _min?: DiscordUserMinAggregateInputType
    _max?: DiscordUserMaxAggregateInputType
  }


  export type DiscordUserGroupByOutputType = {
    username: string
    notionAuthId: string
    _count: DiscordUserCountAggregateOutputType | null
    _min: DiscordUserMinAggregateOutputType | null
    _max: DiscordUserMaxAggregateOutputType | null
  }

  type GetDiscordUserGroupByPayload<T extends DiscordUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscordUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscordUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscordUserGroupByOutputType[P]>
            : GetScalarType<T[P], DiscordUserGroupByOutputType[P]>
        }
      >
    >


  export type DiscordUserSelect = {
    username?: boolean
    notionAuthId?: boolean
    NotionAuth?: boolean | NotionAuthArgs
  }

  export type DiscordUserInclude = {
    NotionAuth?: boolean | NotionAuthArgs
  }

  export type DiscordUserGetPayload<
    S extends boolean | null | undefined | DiscordUserArgs,
    U = keyof S
      > = S extends true
        ? DiscordUser
    : S extends undefined
    ? never
    : S extends DiscordUserArgs | DiscordUserFindManyArgs
    ?'include' extends U
    ? DiscordUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'NotionAuth' ? NotionAuthGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'NotionAuth' ? NotionAuthGetPayload<S['select'][P]> :  P extends keyof DiscordUser ? DiscordUser[P] : never
  } 
    : DiscordUser
  : DiscordUser


  type DiscordUserCountArgs = Merge<
    Omit<DiscordUserFindManyArgs, 'select' | 'include'> & {
      select?: DiscordUserCountAggregateInputType | true
    }
  >

  export interface DiscordUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DiscordUser that matches the filter.
     * @param {DiscordUserFindUniqueArgs} args - Arguments to find a DiscordUser
     * @example
     * // Get one DiscordUser
     * const discordUser = await prisma.discordUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscordUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscordUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DiscordUser'> extends True ? CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>> : CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>

    /**
     * Find the first DiscordUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordUserFindFirstArgs} args - Arguments to find a DiscordUser
     * @example
     * // Get one DiscordUser
     * const discordUser = await prisma.discordUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscordUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscordUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DiscordUser'> extends True ? CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>> : CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>

    /**
     * Find zero or more DiscordUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscordUsers
     * const discordUsers = await prisma.discordUser.findMany()
     * 
     * // Get first 10 DiscordUsers
     * const discordUsers = await prisma.discordUser.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const discordUserWithUsernameOnly = await prisma.discordUser.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends DiscordUserFindManyArgs>(
      args?: SelectSubset<T, DiscordUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DiscordUser>>, PrismaPromise<Array<DiscordUserGetPayload<T>>>>

    /**
     * Create a DiscordUser.
     * @param {DiscordUserCreateArgs} args - Arguments to create a DiscordUser.
     * @example
     * // Create one DiscordUser
     * const DiscordUser = await prisma.discordUser.create({
     *   data: {
     *     // ... data to create a DiscordUser
     *   }
     * })
     * 
    **/
    create<T extends DiscordUserCreateArgs>(
      args: SelectSubset<T, DiscordUserCreateArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Create many DiscordUsers.
     *     @param {DiscordUserCreateManyArgs} args - Arguments to create many DiscordUsers.
     *     @example
     *     // Create many DiscordUsers
     *     const discordUser = await prisma.discordUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscordUserCreateManyArgs>(
      args?: SelectSubset<T, DiscordUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DiscordUser.
     * @param {DiscordUserDeleteArgs} args - Arguments to delete one DiscordUser.
     * @example
     * // Delete one DiscordUser
     * const DiscordUser = await prisma.discordUser.delete({
     *   where: {
     *     // ... filter to delete one DiscordUser
     *   }
     * })
     * 
    **/
    delete<T extends DiscordUserDeleteArgs>(
      args: SelectSubset<T, DiscordUserDeleteArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Update one DiscordUser.
     * @param {DiscordUserUpdateArgs} args - Arguments to update one DiscordUser.
     * @example
     * // Update one DiscordUser
     * const discordUser = await prisma.discordUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscordUserUpdateArgs>(
      args: SelectSubset<T, DiscordUserUpdateArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Delete zero or more DiscordUsers.
     * @param {DiscordUserDeleteManyArgs} args - Arguments to filter DiscordUsers to delete.
     * @example
     * // Delete a few DiscordUsers
     * const { count } = await prisma.discordUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscordUserDeleteManyArgs>(
      args?: SelectSubset<T, DiscordUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscordUsers
     * const discordUser = await prisma.discordUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscordUserUpdateManyArgs>(
      args: SelectSubset<T, DiscordUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscordUser.
     * @param {DiscordUserUpsertArgs} args - Arguments to update or create a DiscordUser.
     * @example
     * // Update or create a DiscordUser
     * const discordUser = await prisma.discordUser.upsert({
     *   create: {
     *     // ... data to create a DiscordUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscordUser we want to update
     *   }
     * })
    **/
    upsert<T extends DiscordUserUpsertArgs>(
      args: SelectSubset<T, DiscordUserUpsertArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Count the number of DiscordUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordUserCountArgs} args - Arguments to filter DiscordUsers to count.
     * @example
     * // Count the number of DiscordUsers
     * const count = await prisma.discordUser.count({
     *   where: {
     *     // ... the filter for the DiscordUsers we want to count
     *   }
     * })
    **/
    count<T extends DiscordUserCountArgs>(
      args?: Subset<T, DiscordUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscordUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscordUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscordUserAggregateArgs>(args: Subset<T, DiscordUserAggregateArgs>): PrismaPromise<GetDiscordUserAggregateType<T>>

    /**
     * Group by DiscordUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscordUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscordUserGroupByArgs['orderBy'] }
        : { orderBy?: DiscordUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscordUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscordUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscordUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscordUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    NotionAuth<T extends NotionAuthArgs = {}>(args?: Subset<T, NotionAuthArgs>): CheckSelect<T, Prisma__NotionAuthClient<NotionAuth | null >, Prisma__NotionAuthClient<NotionAuthGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DiscordUser findUnique
   */
  export type DiscordUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * Throw an Error if a DiscordUser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscordUser to fetch.
     * 
    **/
    where: DiscordUserWhereUniqueInput
  }


  /**
   * DiscordUser findFirst
   */
  export type DiscordUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * Throw an Error if a DiscordUser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscordUser to fetch.
     * 
    **/
    where?: DiscordUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscordUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordUsers.
     * 
    **/
    cursor?: DiscordUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordUsers.
     * 
    **/
    distinct?: Enumerable<DiscordUserScalarFieldEnum>
  }


  /**
   * DiscordUser findMany
   */
  export type DiscordUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * Filter, which DiscordUsers to fetch.
     * 
    **/
    where?: DiscordUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscordUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscordUsers.
     * 
    **/
    cursor?: DiscordUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscordUserScalarFieldEnum>
  }


  /**
   * DiscordUser create
   */
  export type DiscordUserCreateArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * The data needed to create a DiscordUser.
     * 
    **/
    data: XOR<DiscordUserCreateInput, DiscordUserUncheckedCreateInput>
  }


  /**
   * DiscordUser createMany
   */
  export type DiscordUserCreateManyArgs = {
    /**
     * The data used to create many DiscordUsers.
     * 
    **/
    data: Enumerable<DiscordUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DiscordUser update
   */
  export type DiscordUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * The data needed to update a DiscordUser.
     * 
    **/
    data: XOR<DiscordUserUpdateInput, DiscordUserUncheckedUpdateInput>
    /**
     * Choose, which DiscordUser to update.
     * 
    **/
    where: DiscordUserWhereUniqueInput
  }


  /**
   * DiscordUser updateMany
   */
  export type DiscordUserUpdateManyArgs = {
    /**
     * The data used to update DiscordUsers.
     * 
    **/
    data: XOR<DiscordUserUpdateManyMutationInput, DiscordUserUncheckedUpdateManyInput>
    /**
     * Filter which DiscordUsers to update
     * 
    **/
    where?: DiscordUserWhereInput
  }


  /**
   * DiscordUser upsert
   */
  export type DiscordUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * The filter to search for the DiscordUser to update in case it exists.
     * 
    **/
    where: DiscordUserWhereUniqueInput
    /**
     * In case the DiscordUser found by the `where` argument doesn't exist, create a new DiscordUser with this data.
     * 
    **/
    create: XOR<DiscordUserCreateInput, DiscordUserUncheckedCreateInput>
    /**
     * In case the DiscordUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscordUserUpdateInput, DiscordUserUncheckedUpdateInput>
  }


  /**
   * DiscordUser delete
   */
  export type DiscordUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
    /**
     * Filter which DiscordUser to delete.
     * 
    **/
    where: DiscordUserWhereUniqueInput
  }


  /**
   * DiscordUser deleteMany
   */
  export type DiscordUserDeleteManyArgs = {
    /**
     * Filter which DiscordUsers to delete
     * 
    **/
    where?: DiscordUserWhereInput
  }


  /**
   * DiscordUser without action
   */
  export type DiscordUserArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
     * 
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscordUserInclude | null
  }



  /**
   * Model Feature
   */


  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureAvgAggregateOutputType = {
    id: number | null
    columnState: number | null
    rankState: number | null
  }

  export type FeatureSumAggregateOutputType = {
    id: number | null
    columnState: number | null
    rankState: number | null
  }

  export type FeatureMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    userId: string | null
    columnState: number | null
    rankState: number | null
    isSearched: boolean | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    userId: string | null
    columnState: number | null
    rankState: number | null
    isSearched: boolean | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    title: number
    description: number
    userId: number
    columnState: number
    rankState: number
    isSearched: number
    _all: number
  }


  export type FeatureAvgAggregateInputType = {
    id?: true
    columnState?: true
    rankState?: true
  }

  export type FeatureSumAggregateInputType = {
    id?: true
    columnState?: true
    rankState?: true
  }

  export type FeatureMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    columnState?: true
    rankState?: true
    isSearched?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    columnState?: true
    rankState?: true
    isSearched?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    columnState?: true
    rankState?: true
    isSearched?: true
    _all?: true
  }

  export type FeatureAggregateArgs = {
    /**
     * Filter which Feature to aggregate.
     * 
    **/
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs = {
    where?: FeatureWhereInput
    orderBy?: Enumerable<FeatureOrderByWithAggregationInput>
    by: Array<FeatureScalarFieldEnum>
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _avg?: FeatureAvgAggregateInputType
    _sum?: FeatureSumAggregateInputType
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }


  export type FeatureGroupByOutputType = {
    id: number
    title: string
    description: string
    userId: string
    columnState: number
    rankState: number
    isSearched: boolean
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    columnState?: boolean
    rankState?: boolean
    isSearched?: boolean
    User?: boolean | UserArgs
    FeatureRequestMap?: boolean | FeatureRequestMapFindManyArgs
    _count?: boolean | FeatureCountOutputTypeArgs
  }

  export type FeatureInclude = {
    User?: boolean | UserArgs
    FeatureRequestMap?: boolean | FeatureRequestMapFindManyArgs
    _count?: boolean | FeatureCountOutputTypeArgs
  }

  export type FeatureGetPayload<
    S extends boolean | null | undefined | FeatureArgs,
    U = keyof S
      > = S extends true
        ? Feature
    : S extends undefined
    ? never
    : S extends FeatureArgs | FeatureFindManyArgs
    ?'include' extends U
    ? Feature  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'FeatureRequestMap' ? Array < FeatureRequestMapGetPayload<S['include'][P]>>  :
        P extends '_count' ? FeatureCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'FeatureRequestMap' ? Array < FeatureRequestMapGetPayload<S['select'][P]>>  :
        P extends '_count' ? FeatureCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Feature ? Feature[P] : never
  } 
    : Feature
  : Feature


  type FeatureCountArgs = Merge<
    Omit<FeatureFindManyArgs, 'select' | 'include'> & {
      select?: FeatureCountAggregateInputType | true
    }
  >

  export interface FeatureDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeatureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeatureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Feature'> extends True ? CheckSelect<T, Prisma__FeatureClient<Feature>, Prisma__FeatureClient<FeatureGetPayload<T>>> : CheckSelect<T, Prisma__FeatureClient<Feature | null >, Prisma__FeatureClient<FeatureGetPayload<T> | null >>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeatureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeatureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Feature'> extends True ? CheckSelect<T, Prisma__FeatureClient<Feature>, Prisma__FeatureClient<FeatureGetPayload<T>>> : CheckSelect<T, Prisma__FeatureClient<Feature | null >, Prisma__FeatureClient<FeatureGetPayload<T> | null >>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeatureFindManyArgs>(
      args?: SelectSubset<T, FeatureFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Feature>>, PrismaPromise<Array<FeatureGetPayload<T>>>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
    **/
    create<T extends FeatureCreateArgs>(
      args: SelectSubset<T, FeatureCreateArgs>
    ): CheckSelect<T, Prisma__FeatureClient<Feature>, Prisma__FeatureClient<FeatureGetPayload<T>>>

    /**
     * Create many Features.
     *     @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     *     @example
     *     // Create many Features
     *     const feature = await prisma.feature.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeatureCreateManyArgs>(
      args?: SelectSubset<T, FeatureCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
    **/
    delete<T extends FeatureDeleteArgs>(
      args: SelectSubset<T, FeatureDeleteArgs>
    ): CheckSelect<T, Prisma__FeatureClient<Feature>, Prisma__FeatureClient<FeatureGetPayload<T>>>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeatureUpdateArgs>(
      args: SelectSubset<T, FeatureUpdateArgs>
    ): CheckSelect<T, Prisma__FeatureClient<Feature>, Prisma__FeatureClient<FeatureGetPayload<T>>>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeatureDeleteManyArgs>(
      args?: SelectSubset<T, FeatureDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeatureUpdateManyArgs>(
      args: SelectSubset<T, FeatureUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
    **/
    upsert<T extends FeatureUpsertArgs>(
      args: SelectSubset<T, FeatureUpsertArgs>
    ): CheckSelect<T, Prisma__FeatureClient<Feature>, Prisma__FeatureClient<FeatureGetPayload<T>>>

    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeatureClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    FeatureRequestMap<T extends FeatureRequestMapFindManyArgs = {}>(args?: Subset<T, FeatureRequestMapFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FeatureRequestMap>>, PrismaPromise<Array<FeatureRequestMapGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * Throw an Error if a Feature can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Feature to fetch.
     * 
    **/
    where: FeatureWhereUniqueInput
  }


  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * Throw an Error if a Feature can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Feature to fetch.
     * 
    **/
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     * 
    **/
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     * 
    **/
    distinct?: Enumerable<FeatureScalarFieldEnum>
  }


  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * Filter, which Features to fetch.
     * 
    **/
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     * 
    **/
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeatureScalarFieldEnum>
  }


  /**
   * Feature create
   */
  export type FeatureCreateArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * The data needed to create a Feature.
     * 
    **/
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }


  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs = {
    /**
     * The data used to create many Features.
     * 
    **/
    data: Enumerable<FeatureCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Feature update
   */
  export type FeatureUpdateArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * The data needed to update a Feature.
     * 
    **/
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     * 
    **/
    where: FeatureWhereUniqueInput
  }


  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs = {
    /**
     * The data used to update Features.
     * 
    **/
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     * 
    **/
    where?: FeatureWhereInput
  }


  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * The filter to search for the Feature to update in case it exists.
     * 
    **/
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     * 
    **/
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }


  /**
   * Feature delete
   */
  export type FeatureDeleteArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
    /**
     * Filter which Feature to delete.
     * 
    **/
    where: FeatureWhereUniqueInput
  }


  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs = {
    /**
     * Filter which Features to delete
     * 
    **/
    where?: FeatureWhereInput
  }


  /**
   * Feature without action
   */
  export type FeatureArgs = {
    /**
     * Select specific fields to fetch from the Feature
     * 
    **/
    select?: FeatureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureInclude | null
  }



  /**
   * Model FeatureRequest
   */


  export type AggregateFeatureRequest = {
    _count: FeatureRequestCountAggregateOutputType | null
    _avg: FeatureRequestAvgAggregateOutputType | null
    _sum: FeatureRequestSumAggregateOutputType | null
    _min: FeatureRequestMinAggregateOutputType | null
    _max: FeatureRequestMaxAggregateOutputType | null
  }

  export type FeatureRequestAvgAggregateOutputType = {
    kmeans_labels: number | null
  }

  export type FeatureRequestSumAggregateOutputType = {
    kmeans_labels: number | null
  }

  export type FeatureRequestMinAggregateOutputType = {
    fr_id: string | null
    message_id: string | null
    message: string | null
    created_at: string | null
    author: string | null
    label: string | null
    fr: string | null
    kmeans_labels: number | null
    userId: string | null
  }

  export type FeatureRequestMaxAggregateOutputType = {
    fr_id: string | null
    message_id: string | null
    message: string | null
    created_at: string | null
    author: string | null
    label: string | null
    fr: string | null
    kmeans_labels: number | null
    userId: string | null
  }

  export type FeatureRequestCountAggregateOutputType = {
    fr_id: number
    message_id: number
    message: number
    created_at: number
    author: number
    label: number
    fr: number
    kmeans_labels: number
    userId: number
    _all: number
  }


  export type FeatureRequestAvgAggregateInputType = {
    kmeans_labels?: true
  }

  export type FeatureRequestSumAggregateInputType = {
    kmeans_labels?: true
  }

  export type FeatureRequestMinAggregateInputType = {
    fr_id?: true
    message_id?: true
    message?: true
    created_at?: true
    author?: true
    label?: true
    fr?: true
    kmeans_labels?: true
    userId?: true
  }

  export type FeatureRequestMaxAggregateInputType = {
    fr_id?: true
    message_id?: true
    message?: true
    created_at?: true
    author?: true
    label?: true
    fr?: true
    kmeans_labels?: true
    userId?: true
  }

  export type FeatureRequestCountAggregateInputType = {
    fr_id?: true
    message_id?: true
    message?: true
    created_at?: true
    author?: true
    label?: true
    fr?: true
    kmeans_labels?: true
    userId?: true
    _all?: true
  }

  export type FeatureRequestAggregateArgs = {
    /**
     * Filter which FeatureRequest to aggregate.
     * 
    **/
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureRequests
    **/
    _count?: true | FeatureRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureRequestMaxAggregateInputType
  }

  export type GetFeatureRequestAggregateType<T extends FeatureRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureRequest[P]>
      : GetScalarType<T[P], AggregateFeatureRequest[P]>
  }




  export type FeatureRequestGroupByArgs = {
    where?: FeatureRequestWhereInput
    orderBy?: Enumerable<FeatureRequestOrderByWithAggregationInput>
    by: Array<FeatureRequestScalarFieldEnum>
    having?: FeatureRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureRequestCountAggregateInputType | true
    _avg?: FeatureRequestAvgAggregateInputType
    _sum?: FeatureRequestSumAggregateInputType
    _min?: FeatureRequestMinAggregateInputType
    _max?: FeatureRequestMaxAggregateInputType
  }


  export type FeatureRequestGroupByOutputType = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    userId: string
    _count: FeatureRequestCountAggregateOutputType | null
    _avg: FeatureRequestAvgAggregateOutputType | null
    _sum: FeatureRequestSumAggregateOutputType | null
    _min: FeatureRequestMinAggregateOutputType | null
    _max: FeatureRequestMaxAggregateOutputType | null
  }

  type GetFeatureRequestGroupByPayload<T extends FeatureRequestGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FeatureRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureRequestGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureRequestGroupByOutputType[P]>
        }
      >
    >


  export type FeatureRequestSelect = {
    fr_id?: boolean
    message_id?: boolean
    message?: boolean
    created_at?: boolean
    author?: boolean
    label?: boolean
    fr?: boolean
    kmeans_labels?: boolean
    userId?: boolean
    User?: boolean | UserArgs
    FeatureRequestMap?: boolean | FeatureRequestMapFindManyArgs
    _count?: boolean | FeatureRequestCountOutputTypeArgs
  }

  export type FeatureRequestInclude = {
    User?: boolean | UserArgs
    FeatureRequestMap?: boolean | FeatureRequestMapFindManyArgs
    _count?: boolean | FeatureRequestCountOutputTypeArgs
  }

  export type FeatureRequestGetPayload<
    S extends boolean | null | undefined | FeatureRequestArgs,
    U = keyof S
      > = S extends true
        ? FeatureRequest
    : S extends undefined
    ? never
    : S extends FeatureRequestArgs | FeatureRequestFindManyArgs
    ?'include' extends U
    ? FeatureRequest  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'FeatureRequestMap' ? Array < FeatureRequestMapGetPayload<S['include'][P]>>  :
        P extends '_count' ? FeatureRequestCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'FeatureRequestMap' ? Array < FeatureRequestMapGetPayload<S['select'][P]>>  :
        P extends '_count' ? FeatureRequestCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FeatureRequest ? FeatureRequest[P] : never
  } 
    : FeatureRequest
  : FeatureRequest


  type FeatureRequestCountArgs = Merge<
    Omit<FeatureRequestFindManyArgs, 'select' | 'include'> & {
      select?: FeatureRequestCountAggregateInputType | true
    }
  >

  export interface FeatureRequestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FeatureRequest that matches the filter.
     * @param {FeatureRequestFindUniqueArgs} args - Arguments to find a FeatureRequest
     * @example
     * // Get one FeatureRequest
     * const featureRequest = await prisma.featureRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeatureRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeatureRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FeatureRequest'> extends True ? CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest>, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T>>> : CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest | null >, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T> | null >>

    /**
     * Find the first FeatureRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestFindFirstArgs} args - Arguments to find a FeatureRequest
     * @example
     * // Get one FeatureRequest
     * const featureRequest = await prisma.featureRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeatureRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeatureRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FeatureRequest'> extends True ? CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest>, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T>>> : CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest | null >, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T> | null >>

    /**
     * Find zero or more FeatureRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureRequests
     * const featureRequests = await prisma.featureRequest.findMany()
     * 
     * // Get first 10 FeatureRequests
     * const featureRequests = await prisma.featureRequest.findMany({ take: 10 })
     * 
     * // Only select the `fr_id`
     * const featureRequestWithFr_idOnly = await prisma.featureRequest.findMany({ select: { fr_id: true } })
     * 
    **/
    findMany<T extends FeatureRequestFindManyArgs>(
      args?: SelectSubset<T, FeatureRequestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FeatureRequest>>, PrismaPromise<Array<FeatureRequestGetPayload<T>>>>

    /**
     * Create a FeatureRequest.
     * @param {FeatureRequestCreateArgs} args - Arguments to create a FeatureRequest.
     * @example
     * // Create one FeatureRequest
     * const FeatureRequest = await prisma.featureRequest.create({
     *   data: {
     *     // ... data to create a FeatureRequest
     *   }
     * })
     * 
    **/
    create<T extends FeatureRequestCreateArgs>(
      args: SelectSubset<T, FeatureRequestCreateArgs>
    ): CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest>, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T>>>

    /**
     * Create many FeatureRequests.
     *     @param {FeatureRequestCreateManyArgs} args - Arguments to create many FeatureRequests.
     *     @example
     *     // Create many FeatureRequests
     *     const featureRequest = await prisma.featureRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeatureRequestCreateManyArgs>(
      args?: SelectSubset<T, FeatureRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FeatureRequest.
     * @param {FeatureRequestDeleteArgs} args - Arguments to delete one FeatureRequest.
     * @example
     * // Delete one FeatureRequest
     * const FeatureRequest = await prisma.featureRequest.delete({
     *   where: {
     *     // ... filter to delete one FeatureRequest
     *   }
     * })
     * 
    **/
    delete<T extends FeatureRequestDeleteArgs>(
      args: SelectSubset<T, FeatureRequestDeleteArgs>
    ): CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest>, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T>>>

    /**
     * Update one FeatureRequest.
     * @param {FeatureRequestUpdateArgs} args - Arguments to update one FeatureRequest.
     * @example
     * // Update one FeatureRequest
     * const featureRequest = await prisma.featureRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeatureRequestUpdateArgs>(
      args: SelectSubset<T, FeatureRequestUpdateArgs>
    ): CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest>, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T>>>

    /**
     * Delete zero or more FeatureRequests.
     * @param {FeatureRequestDeleteManyArgs} args - Arguments to filter FeatureRequests to delete.
     * @example
     * // Delete a few FeatureRequests
     * const { count } = await prisma.featureRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeatureRequestDeleteManyArgs>(
      args?: SelectSubset<T, FeatureRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureRequests
     * const featureRequest = await prisma.featureRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeatureRequestUpdateManyArgs>(
      args: SelectSubset<T, FeatureRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatureRequest.
     * @param {FeatureRequestUpsertArgs} args - Arguments to update or create a FeatureRequest.
     * @example
     * // Update or create a FeatureRequest
     * const featureRequest = await prisma.featureRequest.upsert({
     *   create: {
     *     // ... data to create a FeatureRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureRequest we want to update
     *   }
     * })
    **/
    upsert<T extends FeatureRequestUpsertArgs>(
      args: SelectSubset<T, FeatureRequestUpsertArgs>
    ): CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest>, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T>>>

    /**
     * Count the number of FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestCountArgs} args - Arguments to filter FeatureRequests to count.
     * @example
     * // Count the number of FeatureRequests
     * const count = await prisma.featureRequest.count({
     *   where: {
     *     // ... the filter for the FeatureRequests we want to count
     *   }
     * })
    **/
    count<T extends FeatureRequestCountArgs>(
      args?: Subset<T, FeatureRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureRequestAggregateArgs>(args: Subset<T, FeatureRequestAggregateArgs>): PrismaPromise<GetFeatureRequestAggregateType<T>>

    /**
     * Group by FeatureRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureRequestGroupByArgs['orderBy'] }
        : { orderBy?: FeatureRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureRequestGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeatureRequestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    FeatureRequestMap<T extends FeatureRequestMapFindManyArgs = {}>(args?: Subset<T, FeatureRequestMapFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FeatureRequestMap>>, PrismaPromise<Array<FeatureRequestMapGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FeatureRequest findUnique
   */
  export type FeatureRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * Throw an Error if a FeatureRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FeatureRequest to fetch.
     * 
    **/
    where: FeatureRequestWhereUniqueInput
  }


  /**
   * FeatureRequest findFirst
   */
  export type FeatureRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * Throw an Error if a FeatureRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FeatureRequest to fetch.
     * 
    **/
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureRequests.
     * 
    **/
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureRequests.
     * 
    **/
    distinct?: Enumerable<FeatureRequestScalarFieldEnum>
  }


  /**
   * FeatureRequest findMany
   */
  export type FeatureRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * Filter, which FeatureRequests to fetch.
     * 
    **/
    where?: FeatureRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureRequests.
     * 
    **/
    cursor?: FeatureRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeatureRequestScalarFieldEnum>
  }


  /**
   * FeatureRequest create
   */
  export type FeatureRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * The data needed to create a FeatureRequest.
     * 
    **/
    data: XOR<FeatureRequestCreateInput, FeatureRequestUncheckedCreateInput>
  }


  /**
   * FeatureRequest createMany
   */
  export type FeatureRequestCreateManyArgs = {
    /**
     * The data used to create many FeatureRequests.
     * 
    **/
    data: Enumerable<FeatureRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FeatureRequest update
   */
  export type FeatureRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * The data needed to update a FeatureRequest.
     * 
    **/
    data: XOR<FeatureRequestUpdateInput, FeatureRequestUncheckedUpdateInput>
    /**
     * Choose, which FeatureRequest to update.
     * 
    **/
    where: FeatureRequestWhereUniqueInput
  }


  /**
   * FeatureRequest updateMany
   */
  export type FeatureRequestUpdateManyArgs = {
    /**
     * The data used to update FeatureRequests.
     * 
    **/
    data: XOR<FeatureRequestUpdateManyMutationInput, FeatureRequestUncheckedUpdateManyInput>
    /**
     * Filter which FeatureRequests to update
     * 
    **/
    where?: FeatureRequestWhereInput
  }


  /**
   * FeatureRequest upsert
   */
  export type FeatureRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * The filter to search for the FeatureRequest to update in case it exists.
     * 
    **/
    where: FeatureRequestWhereUniqueInput
    /**
     * In case the FeatureRequest found by the `where` argument doesn't exist, create a new FeatureRequest with this data.
     * 
    **/
    create: XOR<FeatureRequestCreateInput, FeatureRequestUncheckedCreateInput>
    /**
     * In case the FeatureRequest was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeatureRequestUpdateInput, FeatureRequestUncheckedUpdateInput>
  }


  /**
   * FeatureRequest delete
   */
  export type FeatureRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
    /**
     * Filter which FeatureRequest to delete.
     * 
    **/
    where: FeatureRequestWhereUniqueInput
  }


  /**
   * FeatureRequest deleteMany
   */
  export type FeatureRequestDeleteManyArgs = {
    /**
     * Filter which FeatureRequests to delete
     * 
    **/
    where?: FeatureRequestWhereInput
  }


  /**
   * FeatureRequest without action
   */
  export type FeatureRequestArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequest
     * 
    **/
    select?: FeatureRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestInclude | null
  }



  /**
   * Model FeatureRequestMap
   */


  export type AggregateFeatureRequestMap = {
    _count: FeatureRequestMapCountAggregateOutputType | null
    _avg: FeatureRequestMapAvgAggregateOutputType | null
    _sum: FeatureRequestMapSumAggregateOutputType | null
    _min: FeatureRequestMapMinAggregateOutputType | null
    _max: FeatureRequestMapMaxAggregateOutputType | null
  }

  export type FeatureRequestMapAvgAggregateOutputType = {
    featureId: number | null
    cluster: number | null
  }

  export type FeatureRequestMapSumAggregateOutputType = {
    featureId: number | null
    cluster: number | null
  }

  export type FeatureRequestMapMinAggregateOutputType = {
    featureId: number | null
    featureRequestId: string | null
    pinned: boolean | null
    cluster: number | null
  }

  export type FeatureRequestMapMaxAggregateOutputType = {
    featureId: number | null
    featureRequestId: string | null
    pinned: boolean | null
    cluster: number | null
  }

  export type FeatureRequestMapCountAggregateOutputType = {
    featureId: number
    featureRequestId: number
    pinned: number
    cluster: number
    _all: number
  }


  export type FeatureRequestMapAvgAggregateInputType = {
    featureId?: true
    cluster?: true
  }

  export type FeatureRequestMapSumAggregateInputType = {
    featureId?: true
    cluster?: true
  }

  export type FeatureRequestMapMinAggregateInputType = {
    featureId?: true
    featureRequestId?: true
    pinned?: true
    cluster?: true
  }

  export type FeatureRequestMapMaxAggregateInputType = {
    featureId?: true
    featureRequestId?: true
    pinned?: true
    cluster?: true
  }

  export type FeatureRequestMapCountAggregateInputType = {
    featureId?: true
    featureRequestId?: true
    pinned?: true
    cluster?: true
    _all?: true
  }

  export type FeatureRequestMapAggregateArgs = {
    /**
     * Filter which FeatureRequestMap to aggregate.
     * 
    **/
    where?: FeatureRequestMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequestMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureRequestMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeatureRequestMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequestMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequestMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureRequestMaps
    **/
    _count?: true | FeatureRequestMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureRequestMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureRequestMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureRequestMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureRequestMapMaxAggregateInputType
  }

  export type GetFeatureRequestMapAggregateType<T extends FeatureRequestMapAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureRequestMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureRequestMap[P]>
      : GetScalarType<T[P], AggregateFeatureRequestMap[P]>
  }




  export type FeatureRequestMapGroupByArgs = {
    where?: FeatureRequestMapWhereInput
    orderBy?: Enumerable<FeatureRequestMapOrderByWithAggregationInput>
    by: Array<FeatureRequestMapScalarFieldEnum>
    having?: FeatureRequestMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureRequestMapCountAggregateInputType | true
    _avg?: FeatureRequestMapAvgAggregateInputType
    _sum?: FeatureRequestMapSumAggregateInputType
    _min?: FeatureRequestMapMinAggregateInputType
    _max?: FeatureRequestMapMaxAggregateInputType
  }


  export type FeatureRequestMapGroupByOutputType = {
    featureId: number
    featureRequestId: string
    pinned: boolean
    cluster: number
    _count: FeatureRequestMapCountAggregateOutputType | null
    _avg: FeatureRequestMapAvgAggregateOutputType | null
    _sum: FeatureRequestMapSumAggregateOutputType | null
    _min: FeatureRequestMapMinAggregateOutputType | null
    _max: FeatureRequestMapMaxAggregateOutputType | null
  }

  type GetFeatureRequestMapGroupByPayload<T extends FeatureRequestMapGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FeatureRequestMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureRequestMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureRequestMapGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureRequestMapGroupByOutputType[P]>
        }
      >
    >


  export type FeatureRequestMapSelect = {
    featureId?: boolean
    featureRequestId?: boolean
    pinned?: boolean
    cluster?: boolean
    Feature?: boolean | FeatureArgs
    FeatureRequest?: boolean | FeatureRequestArgs
  }

  export type FeatureRequestMapInclude = {
    Feature?: boolean | FeatureArgs
    FeatureRequest?: boolean | FeatureRequestArgs
  }

  export type FeatureRequestMapGetPayload<
    S extends boolean | null | undefined | FeatureRequestMapArgs,
    U = keyof S
      > = S extends true
        ? FeatureRequestMap
    : S extends undefined
    ? never
    : S extends FeatureRequestMapArgs | FeatureRequestMapFindManyArgs
    ?'include' extends U
    ? FeatureRequestMap  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Feature' ? FeatureGetPayload<S['include'][P]> :
        P extends 'FeatureRequest' ? FeatureRequestGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Feature' ? FeatureGetPayload<S['select'][P]> :
        P extends 'FeatureRequest' ? FeatureRequestGetPayload<S['select'][P]> :  P extends keyof FeatureRequestMap ? FeatureRequestMap[P] : never
  } 
    : FeatureRequestMap
  : FeatureRequestMap


  type FeatureRequestMapCountArgs = Merge<
    Omit<FeatureRequestMapFindManyArgs, 'select' | 'include'> & {
      select?: FeatureRequestMapCountAggregateInputType | true
    }
  >

  export interface FeatureRequestMapDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FeatureRequestMap that matches the filter.
     * @param {FeatureRequestMapFindUniqueArgs} args - Arguments to find a FeatureRequestMap
     * @example
     * // Get one FeatureRequestMap
     * const featureRequestMap = await prisma.featureRequestMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeatureRequestMapFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeatureRequestMapFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FeatureRequestMap'> extends True ? CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap>, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T>>> : CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap | null >, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T> | null >>

    /**
     * Find the first FeatureRequestMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestMapFindFirstArgs} args - Arguments to find a FeatureRequestMap
     * @example
     * // Get one FeatureRequestMap
     * const featureRequestMap = await prisma.featureRequestMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeatureRequestMapFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeatureRequestMapFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FeatureRequestMap'> extends True ? CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap>, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T>>> : CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap | null >, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T> | null >>

    /**
     * Find zero or more FeatureRequestMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureRequestMaps
     * const featureRequestMaps = await prisma.featureRequestMap.findMany()
     * 
     * // Get first 10 FeatureRequestMaps
     * const featureRequestMaps = await prisma.featureRequestMap.findMany({ take: 10 })
     * 
     * // Only select the `featureId`
     * const featureRequestMapWithFeatureIdOnly = await prisma.featureRequestMap.findMany({ select: { featureId: true } })
     * 
    **/
    findMany<T extends FeatureRequestMapFindManyArgs>(
      args?: SelectSubset<T, FeatureRequestMapFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FeatureRequestMap>>, PrismaPromise<Array<FeatureRequestMapGetPayload<T>>>>

    /**
     * Create a FeatureRequestMap.
     * @param {FeatureRequestMapCreateArgs} args - Arguments to create a FeatureRequestMap.
     * @example
     * // Create one FeatureRequestMap
     * const FeatureRequestMap = await prisma.featureRequestMap.create({
     *   data: {
     *     // ... data to create a FeatureRequestMap
     *   }
     * })
     * 
    **/
    create<T extends FeatureRequestMapCreateArgs>(
      args: SelectSubset<T, FeatureRequestMapCreateArgs>
    ): CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap>, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T>>>

    /**
     * Create many FeatureRequestMaps.
     *     @param {FeatureRequestMapCreateManyArgs} args - Arguments to create many FeatureRequestMaps.
     *     @example
     *     // Create many FeatureRequestMaps
     *     const featureRequestMap = await prisma.featureRequestMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeatureRequestMapCreateManyArgs>(
      args?: SelectSubset<T, FeatureRequestMapCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FeatureRequestMap.
     * @param {FeatureRequestMapDeleteArgs} args - Arguments to delete one FeatureRequestMap.
     * @example
     * // Delete one FeatureRequestMap
     * const FeatureRequestMap = await prisma.featureRequestMap.delete({
     *   where: {
     *     // ... filter to delete one FeatureRequestMap
     *   }
     * })
     * 
    **/
    delete<T extends FeatureRequestMapDeleteArgs>(
      args: SelectSubset<T, FeatureRequestMapDeleteArgs>
    ): CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap>, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T>>>

    /**
     * Update one FeatureRequestMap.
     * @param {FeatureRequestMapUpdateArgs} args - Arguments to update one FeatureRequestMap.
     * @example
     * // Update one FeatureRequestMap
     * const featureRequestMap = await prisma.featureRequestMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeatureRequestMapUpdateArgs>(
      args: SelectSubset<T, FeatureRequestMapUpdateArgs>
    ): CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap>, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T>>>

    /**
     * Delete zero or more FeatureRequestMaps.
     * @param {FeatureRequestMapDeleteManyArgs} args - Arguments to filter FeatureRequestMaps to delete.
     * @example
     * // Delete a few FeatureRequestMaps
     * const { count } = await prisma.featureRequestMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeatureRequestMapDeleteManyArgs>(
      args?: SelectSubset<T, FeatureRequestMapDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureRequestMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureRequestMaps
     * const featureRequestMap = await prisma.featureRequestMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeatureRequestMapUpdateManyArgs>(
      args: SelectSubset<T, FeatureRequestMapUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatureRequestMap.
     * @param {FeatureRequestMapUpsertArgs} args - Arguments to update or create a FeatureRequestMap.
     * @example
     * // Update or create a FeatureRequestMap
     * const featureRequestMap = await prisma.featureRequestMap.upsert({
     *   create: {
     *     // ... data to create a FeatureRequestMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureRequestMap we want to update
     *   }
     * })
    **/
    upsert<T extends FeatureRequestMapUpsertArgs>(
      args: SelectSubset<T, FeatureRequestMapUpsertArgs>
    ): CheckSelect<T, Prisma__FeatureRequestMapClient<FeatureRequestMap>, Prisma__FeatureRequestMapClient<FeatureRequestMapGetPayload<T>>>

    /**
     * Count the number of FeatureRequestMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestMapCountArgs} args - Arguments to filter FeatureRequestMaps to count.
     * @example
     * // Count the number of FeatureRequestMaps
     * const count = await prisma.featureRequestMap.count({
     *   where: {
     *     // ... the filter for the FeatureRequestMaps we want to count
     *   }
     * })
    **/
    count<T extends FeatureRequestMapCountArgs>(
      args?: Subset<T, FeatureRequestMapCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureRequestMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureRequestMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureRequestMapAggregateArgs>(args: Subset<T, FeatureRequestMapAggregateArgs>): PrismaPromise<GetFeatureRequestMapAggregateType<T>>

    /**
     * Group by FeatureRequestMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureRequestMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureRequestMapGroupByArgs['orderBy'] }
        : { orderBy?: FeatureRequestMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureRequestMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureRequestMapGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureRequestMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeatureRequestMapClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Feature<T extends FeatureArgs = {}>(args?: Subset<T, FeatureArgs>): CheckSelect<T, Prisma__FeatureClient<Feature | null >, Prisma__FeatureClient<FeatureGetPayload<T> | null >>;

    FeatureRequest<T extends FeatureRequestArgs = {}>(args?: Subset<T, FeatureRequestArgs>): CheckSelect<T, Prisma__FeatureRequestClient<FeatureRequest | null >, Prisma__FeatureRequestClient<FeatureRequestGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FeatureRequestMap findUnique
   */
  export type FeatureRequestMapFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * Throw an Error if a FeatureRequestMap can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FeatureRequestMap to fetch.
     * 
    **/
    where: FeatureRequestMapWhereUniqueInput
  }


  /**
   * FeatureRequestMap findFirst
   */
  export type FeatureRequestMapFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * Throw an Error if a FeatureRequestMap can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FeatureRequestMap to fetch.
     * 
    **/
    where?: FeatureRequestMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequestMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureRequestMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureRequestMaps.
     * 
    **/
    cursor?: FeatureRequestMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequestMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequestMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureRequestMaps.
     * 
    **/
    distinct?: Enumerable<FeatureRequestMapScalarFieldEnum>
  }


  /**
   * FeatureRequestMap findMany
   */
  export type FeatureRequestMapFindManyArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * Filter, which FeatureRequestMaps to fetch.
     * 
    **/
    where?: FeatureRequestMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequestMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<FeatureRequestMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureRequestMaps.
     * 
    **/
    cursor?: FeatureRequestMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequestMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequestMaps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeatureRequestMapScalarFieldEnum>
  }


  /**
   * FeatureRequestMap create
   */
  export type FeatureRequestMapCreateArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * The data needed to create a FeatureRequestMap.
     * 
    **/
    data: XOR<FeatureRequestMapCreateInput, FeatureRequestMapUncheckedCreateInput>
  }


  /**
   * FeatureRequestMap createMany
   */
  export type FeatureRequestMapCreateManyArgs = {
    /**
     * The data used to create many FeatureRequestMaps.
     * 
    **/
    data: Enumerable<FeatureRequestMapCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FeatureRequestMap update
   */
  export type FeatureRequestMapUpdateArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * The data needed to update a FeatureRequestMap.
     * 
    **/
    data: XOR<FeatureRequestMapUpdateInput, FeatureRequestMapUncheckedUpdateInput>
    /**
     * Choose, which FeatureRequestMap to update.
     * 
    **/
    where: FeatureRequestMapWhereUniqueInput
  }


  /**
   * FeatureRequestMap updateMany
   */
  export type FeatureRequestMapUpdateManyArgs = {
    /**
     * The data used to update FeatureRequestMaps.
     * 
    **/
    data: XOR<FeatureRequestMapUpdateManyMutationInput, FeatureRequestMapUncheckedUpdateManyInput>
    /**
     * Filter which FeatureRequestMaps to update
     * 
    **/
    where?: FeatureRequestMapWhereInput
  }


  /**
   * FeatureRequestMap upsert
   */
  export type FeatureRequestMapUpsertArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * The filter to search for the FeatureRequestMap to update in case it exists.
     * 
    **/
    where: FeatureRequestMapWhereUniqueInput
    /**
     * In case the FeatureRequestMap found by the `where` argument doesn't exist, create a new FeatureRequestMap with this data.
     * 
    **/
    create: XOR<FeatureRequestMapCreateInput, FeatureRequestMapUncheckedCreateInput>
    /**
     * In case the FeatureRequestMap was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeatureRequestMapUpdateInput, FeatureRequestMapUncheckedUpdateInput>
  }


  /**
   * FeatureRequestMap delete
   */
  export type FeatureRequestMapDeleteArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
    /**
     * Filter which FeatureRequestMap to delete.
     * 
    **/
    where: FeatureRequestMapWhereUniqueInput
  }


  /**
   * FeatureRequestMap deleteMany
   */
  export type FeatureRequestMapDeleteManyArgs = {
    /**
     * Filter which FeatureRequestMaps to delete
     * 
    **/
    where?: FeatureRequestMapWhereInput
  }


  /**
   * FeatureRequestMap without action
   */
  export type FeatureRequestMapArgs = {
    /**
     * Select specific fields to fetch from the FeatureRequestMap
     * 
    **/
    select?: FeatureRequestMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeatureRequestMapInclude | null
  }



  /**
   * Model NotionAuth
   */


  export type AggregateNotionAuth = {
    _count: NotionAuthCountAggregateOutputType | null
    _min: NotionAuthMinAggregateOutputType | null
    _max: NotionAuthMaxAggregateOutputType | null
  }

  export type NotionAuthMinAggregateOutputType = {
    botId: string | null
    accessToken: string | null
    owner: string | null
    duplicatedTemplateId: string | null
    workspaceIcon: string | null
    workspaceId: string | null
    workspaceName: string | null
    userId: string | null
    guildName: string | null
  }

  export type NotionAuthMaxAggregateOutputType = {
    botId: string | null
    accessToken: string | null
    owner: string | null
    duplicatedTemplateId: string | null
    workspaceIcon: string | null
    workspaceId: string | null
    workspaceName: string | null
    userId: string | null
    guildName: string | null
  }

  export type NotionAuthCountAggregateOutputType = {
    botId: number
    accessToken: number
    owner: number
    duplicatedTemplateId: number
    workspaceIcon: number
    workspaceId: number
    workspaceName: number
    userId: number
    guildName: number
    _all: number
  }


  export type NotionAuthMinAggregateInputType = {
    botId?: true
    accessToken?: true
    owner?: true
    duplicatedTemplateId?: true
    workspaceIcon?: true
    workspaceId?: true
    workspaceName?: true
    userId?: true
    guildName?: true
  }

  export type NotionAuthMaxAggregateInputType = {
    botId?: true
    accessToken?: true
    owner?: true
    duplicatedTemplateId?: true
    workspaceIcon?: true
    workspaceId?: true
    workspaceName?: true
    userId?: true
    guildName?: true
  }

  export type NotionAuthCountAggregateInputType = {
    botId?: true
    accessToken?: true
    owner?: true
    duplicatedTemplateId?: true
    workspaceIcon?: true
    workspaceId?: true
    workspaceName?: true
    userId?: true
    guildName?: true
    _all?: true
  }

  export type NotionAuthAggregateArgs = {
    /**
     * Filter which NotionAuth to aggregate.
     * 
    **/
    where?: NotionAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotionAuths to fetch.
     * 
    **/
    orderBy?: Enumerable<NotionAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotionAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotionAuths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotionAuths.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotionAuths
    **/
    _count?: true | NotionAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotionAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotionAuthMaxAggregateInputType
  }

  export type GetNotionAuthAggregateType<T extends NotionAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateNotionAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotionAuth[P]>
      : GetScalarType<T[P], AggregateNotionAuth[P]>
  }




  export type NotionAuthGroupByArgs = {
    where?: NotionAuthWhereInput
    orderBy?: Enumerable<NotionAuthOrderByWithAggregationInput>
    by: Array<NotionAuthScalarFieldEnum>
    having?: NotionAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotionAuthCountAggregateInputType | true
    _min?: NotionAuthMinAggregateInputType
    _max?: NotionAuthMaxAggregateInputType
  }


  export type NotionAuthGroupByOutputType = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    userId: string
    guildName: string | null
    _count: NotionAuthCountAggregateOutputType | null
    _min: NotionAuthMinAggregateOutputType | null
    _max: NotionAuthMaxAggregateOutputType | null
  }

  type GetNotionAuthGroupByPayload<T extends NotionAuthGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotionAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotionAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotionAuthGroupByOutputType[P]>
            : GetScalarType<T[P], NotionAuthGroupByOutputType[P]>
        }
      >
    >


  export type NotionAuthSelect = {
    botId?: boolean
    accessToken?: boolean
    owner?: boolean
    duplicatedTemplateId?: boolean
    workspaceIcon?: boolean
    workspaceId?: boolean
    workspaceName?: boolean
    userId?: boolean
    guildName?: boolean
    User?: boolean | UserArgs
    DiscordUser?: boolean | DiscordUserFindManyArgs
    _count?: boolean | NotionAuthCountOutputTypeArgs
  }

  export type NotionAuthInclude = {
    User?: boolean | UserArgs
    DiscordUser?: boolean | DiscordUserFindManyArgs
    _count?: boolean | NotionAuthCountOutputTypeArgs
  }

  export type NotionAuthGetPayload<
    S extends boolean | null | undefined | NotionAuthArgs,
    U = keyof S
      > = S extends true
        ? NotionAuth
    : S extends undefined
    ? never
    : S extends NotionAuthArgs | NotionAuthFindManyArgs
    ?'include' extends U
    ? NotionAuth  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'DiscordUser' ? Array < DiscordUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? NotionAuthCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'DiscordUser' ? Array < DiscordUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? NotionAuthCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof NotionAuth ? NotionAuth[P] : never
  } 
    : NotionAuth
  : NotionAuth


  type NotionAuthCountArgs = Merge<
    Omit<NotionAuthFindManyArgs, 'select' | 'include'> & {
      select?: NotionAuthCountAggregateInputType | true
    }
  >

  export interface NotionAuthDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NotionAuth that matches the filter.
     * @param {NotionAuthFindUniqueArgs} args - Arguments to find a NotionAuth
     * @example
     * // Get one NotionAuth
     * const notionAuth = await prisma.notionAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotionAuthFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotionAuthFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NotionAuth'> extends True ? CheckSelect<T, Prisma__NotionAuthClient<NotionAuth>, Prisma__NotionAuthClient<NotionAuthGetPayload<T>>> : CheckSelect<T, Prisma__NotionAuthClient<NotionAuth | null >, Prisma__NotionAuthClient<NotionAuthGetPayload<T> | null >>

    /**
     * Find the first NotionAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotionAuthFindFirstArgs} args - Arguments to find a NotionAuth
     * @example
     * // Get one NotionAuth
     * const notionAuth = await prisma.notionAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotionAuthFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotionAuthFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NotionAuth'> extends True ? CheckSelect<T, Prisma__NotionAuthClient<NotionAuth>, Prisma__NotionAuthClient<NotionAuthGetPayload<T>>> : CheckSelect<T, Prisma__NotionAuthClient<NotionAuth | null >, Prisma__NotionAuthClient<NotionAuthGetPayload<T> | null >>

    /**
     * Find zero or more NotionAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotionAuthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotionAuths
     * const notionAuths = await prisma.notionAuth.findMany()
     * 
     * // Get first 10 NotionAuths
     * const notionAuths = await prisma.notionAuth.findMany({ take: 10 })
     * 
     * // Only select the `botId`
     * const notionAuthWithBotIdOnly = await prisma.notionAuth.findMany({ select: { botId: true } })
     * 
    **/
    findMany<T extends NotionAuthFindManyArgs>(
      args?: SelectSubset<T, NotionAuthFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<NotionAuth>>, PrismaPromise<Array<NotionAuthGetPayload<T>>>>

    /**
     * Create a NotionAuth.
     * @param {NotionAuthCreateArgs} args - Arguments to create a NotionAuth.
     * @example
     * // Create one NotionAuth
     * const NotionAuth = await prisma.notionAuth.create({
     *   data: {
     *     // ... data to create a NotionAuth
     *   }
     * })
     * 
    **/
    create<T extends NotionAuthCreateArgs>(
      args: SelectSubset<T, NotionAuthCreateArgs>
    ): CheckSelect<T, Prisma__NotionAuthClient<NotionAuth>, Prisma__NotionAuthClient<NotionAuthGetPayload<T>>>

    /**
     * Create many NotionAuths.
     *     @param {NotionAuthCreateManyArgs} args - Arguments to create many NotionAuths.
     *     @example
     *     // Create many NotionAuths
     *     const notionAuth = await prisma.notionAuth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotionAuthCreateManyArgs>(
      args?: SelectSubset<T, NotionAuthCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NotionAuth.
     * @param {NotionAuthDeleteArgs} args - Arguments to delete one NotionAuth.
     * @example
     * // Delete one NotionAuth
     * const NotionAuth = await prisma.notionAuth.delete({
     *   where: {
     *     // ... filter to delete one NotionAuth
     *   }
     * })
     * 
    **/
    delete<T extends NotionAuthDeleteArgs>(
      args: SelectSubset<T, NotionAuthDeleteArgs>
    ): CheckSelect<T, Prisma__NotionAuthClient<NotionAuth>, Prisma__NotionAuthClient<NotionAuthGetPayload<T>>>

    /**
     * Update one NotionAuth.
     * @param {NotionAuthUpdateArgs} args - Arguments to update one NotionAuth.
     * @example
     * // Update one NotionAuth
     * const notionAuth = await prisma.notionAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotionAuthUpdateArgs>(
      args: SelectSubset<T, NotionAuthUpdateArgs>
    ): CheckSelect<T, Prisma__NotionAuthClient<NotionAuth>, Prisma__NotionAuthClient<NotionAuthGetPayload<T>>>

    /**
     * Delete zero or more NotionAuths.
     * @param {NotionAuthDeleteManyArgs} args - Arguments to filter NotionAuths to delete.
     * @example
     * // Delete a few NotionAuths
     * const { count } = await prisma.notionAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotionAuthDeleteManyArgs>(
      args?: SelectSubset<T, NotionAuthDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotionAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotionAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotionAuths
     * const notionAuth = await prisma.notionAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotionAuthUpdateManyArgs>(
      args: SelectSubset<T, NotionAuthUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NotionAuth.
     * @param {NotionAuthUpsertArgs} args - Arguments to update or create a NotionAuth.
     * @example
     * // Update or create a NotionAuth
     * const notionAuth = await prisma.notionAuth.upsert({
     *   create: {
     *     // ... data to create a NotionAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotionAuth we want to update
     *   }
     * })
    **/
    upsert<T extends NotionAuthUpsertArgs>(
      args: SelectSubset<T, NotionAuthUpsertArgs>
    ): CheckSelect<T, Prisma__NotionAuthClient<NotionAuth>, Prisma__NotionAuthClient<NotionAuthGetPayload<T>>>

    /**
     * Count the number of NotionAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotionAuthCountArgs} args - Arguments to filter NotionAuths to count.
     * @example
     * // Count the number of NotionAuths
     * const count = await prisma.notionAuth.count({
     *   where: {
     *     // ... the filter for the NotionAuths we want to count
     *   }
     * })
    **/
    count<T extends NotionAuthCountArgs>(
      args?: Subset<T, NotionAuthCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotionAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotionAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotionAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotionAuthAggregateArgs>(args: Subset<T, NotionAuthAggregateArgs>): PrismaPromise<GetNotionAuthAggregateType<T>>

    /**
     * Group by NotionAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotionAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotionAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotionAuthGroupByArgs['orderBy'] }
        : { orderBy?: NotionAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotionAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotionAuthGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotionAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotionAuthClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    DiscordUser<T extends DiscordUserFindManyArgs = {}>(args?: Subset<T, DiscordUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DiscordUser>>, PrismaPromise<Array<DiscordUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NotionAuth findUnique
   */
  export type NotionAuthFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * Throw an Error if a NotionAuth can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NotionAuth to fetch.
     * 
    **/
    where: NotionAuthWhereUniqueInput
  }


  /**
   * NotionAuth findFirst
   */
  export type NotionAuthFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * Throw an Error if a NotionAuth can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NotionAuth to fetch.
     * 
    **/
    where?: NotionAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotionAuths to fetch.
     * 
    **/
    orderBy?: Enumerable<NotionAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotionAuths.
     * 
    **/
    cursor?: NotionAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotionAuths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotionAuths.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotionAuths.
     * 
    **/
    distinct?: Enumerable<NotionAuthScalarFieldEnum>
  }


  /**
   * NotionAuth findMany
   */
  export type NotionAuthFindManyArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * Filter, which NotionAuths to fetch.
     * 
    **/
    where?: NotionAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotionAuths to fetch.
     * 
    **/
    orderBy?: Enumerable<NotionAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotionAuths.
     * 
    **/
    cursor?: NotionAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotionAuths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotionAuths.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotionAuthScalarFieldEnum>
  }


  /**
   * NotionAuth create
   */
  export type NotionAuthCreateArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * The data needed to create a NotionAuth.
     * 
    **/
    data: XOR<NotionAuthCreateInput, NotionAuthUncheckedCreateInput>
  }


  /**
   * NotionAuth createMany
   */
  export type NotionAuthCreateManyArgs = {
    /**
     * The data used to create many NotionAuths.
     * 
    **/
    data: Enumerable<NotionAuthCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NotionAuth update
   */
  export type NotionAuthUpdateArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * The data needed to update a NotionAuth.
     * 
    **/
    data: XOR<NotionAuthUpdateInput, NotionAuthUncheckedUpdateInput>
    /**
     * Choose, which NotionAuth to update.
     * 
    **/
    where: NotionAuthWhereUniqueInput
  }


  /**
   * NotionAuth updateMany
   */
  export type NotionAuthUpdateManyArgs = {
    /**
     * The data used to update NotionAuths.
     * 
    **/
    data: XOR<NotionAuthUpdateManyMutationInput, NotionAuthUncheckedUpdateManyInput>
    /**
     * Filter which NotionAuths to update
     * 
    **/
    where?: NotionAuthWhereInput
  }


  /**
   * NotionAuth upsert
   */
  export type NotionAuthUpsertArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * The filter to search for the NotionAuth to update in case it exists.
     * 
    **/
    where: NotionAuthWhereUniqueInput
    /**
     * In case the NotionAuth found by the `where` argument doesn't exist, create a new NotionAuth with this data.
     * 
    **/
    create: XOR<NotionAuthCreateInput, NotionAuthUncheckedCreateInput>
    /**
     * In case the NotionAuth was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotionAuthUpdateInput, NotionAuthUncheckedUpdateInput>
  }


  /**
   * NotionAuth delete
   */
  export type NotionAuthDeleteArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
    /**
     * Filter which NotionAuth to delete.
     * 
    **/
    where: NotionAuthWhereUniqueInput
  }


  /**
   * NotionAuth deleteMany
   */
  export type NotionAuthDeleteManyArgs = {
    /**
     * Filter which NotionAuths to delete
     * 
    **/
    where?: NotionAuthWhereInput
  }


  /**
   * NotionAuth without action
   */
  export type NotionAuthArgs = {
    /**
     * Select specific fields to fetch from the NotionAuth
     * 
    **/
    select?: NotionAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotionAuthInclude | null
  }



  /**
   * Model Thread
   */


  export type AggregateThread = {
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  export type ThreadMinAggregateOutputType = {
    ticketNumber: string | null
    threadName: string | null
    createdTime: string | null
    threadLink: string | null
    bugOverview: string | null
  }

  export type ThreadMaxAggregateOutputType = {
    ticketNumber: string | null
    threadName: string | null
    createdTime: string | null
    threadLink: string | null
    bugOverview: string | null
  }

  export type ThreadCountAggregateOutputType = {
    ticketNumber: number
    threadName: number
    createdTime: number
    threadLink: number
    bugOverview: number
    _all: number
  }


  export type ThreadMinAggregateInputType = {
    ticketNumber?: true
    threadName?: true
    createdTime?: true
    threadLink?: true
    bugOverview?: true
  }

  export type ThreadMaxAggregateInputType = {
    ticketNumber?: true
    threadName?: true
    createdTime?: true
    threadLink?: true
    bugOverview?: true
  }

  export type ThreadCountAggregateInputType = {
    ticketNumber?: true
    threadName?: true
    createdTime?: true
    threadLink?: true
    bugOverview?: true
    _all?: true
  }

  export type ThreadAggregateArgs = {
    /**
     * Filter which Thread to aggregate.
     * 
    **/
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     * 
    **/
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Threads
    **/
    _count?: true | ThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMaxAggregateInputType
  }

  export type GetThreadAggregateType<T extends ThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThread[P]>
      : GetScalarType<T[P], AggregateThread[P]>
  }




  export type ThreadGroupByArgs = {
    where?: ThreadWhereInput
    orderBy?: Enumerable<ThreadOrderByWithAggregationInput>
    by: Array<ThreadScalarFieldEnum>
    having?: ThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCountAggregateInputType | true
    _min?: ThreadMinAggregateInputType
    _max?: ThreadMaxAggregateInputType
  }


  export type ThreadGroupByOutputType = {
    ticketNumber: string
    threadName: string
    createdTime: string
    threadLink: string
    bugOverview: string
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  type GetThreadGroupByPayload<T extends ThreadGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadGroupByOutputType[P]>
        }
      >
    >


  export type ThreadSelect = {
    ticketNumber?: boolean
    threadName?: boolean
    createdTime?: boolean
    threadLink?: boolean
    bugOverview?: boolean
    DiscordMessage?: boolean | DiscordMessageFindManyArgs
    _count?: boolean | ThreadCountOutputTypeArgs
  }

  export type ThreadInclude = {
    DiscordMessage?: boolean | DiscordMessageFindManyArgs
    _count?: boolean | ThreadCountOutputTypeArgs
  }

  export type ThreadGetPayload<
    S extends boolean | null | undefined | ThreadArgs,
    U = keyof S
      > = S extends true
        ? Thread
    : S extends undefined
    ? never
    : S extends ThreadArgs | ThreadFindManyArgs
    ?'include' extends U
    ? Thread  & {
    [P in TrueKeys<S['include']>]:
        P extends 'DiscordMessage' ? Array < DiscordMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? ThreadCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'DiscordMessage' ? Array < DiscordMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? ThreadCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Thread ? Thread[P] : never
  } 
    : Thread
  : Thread


  type ThreadCountArgs = Merge<
    Omit<ThreadFindManyArgs, 'select' | 'include'> & {
      select?: ThreadCountAggregateInputType | true
    }
  >

  export interface ThreadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Thread that matches the filter.
     * @param {ThreadFindUniqueArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThreadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ThreadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Thread'> extends True ? CheckSelect<T, Prisma__ThreadClient<Thread>, Prisma__ThreadClient<ThreadGetPayload<T>>> : CheckSelect<T, Prisma__ThreadClient<Thread | null >, Prisma__ThreadClient<ThreadGetPayload<T> | null >>

    /**
     * Find the first Thread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThreadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ThreadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Thread'> extends True ? CheckSelect<T, Prisma__ThreadClient<Thread>, Prisma__ThreadClient<ThreadGetPayload<T>>> : CheckSelect<T, Prisma__ThreadClient<Thread | null >, Prisma__ThreadClient<ThreadGetPayload<T> | null >>

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.thread.findMany()
     * 
     * // Get first 10 Threads
     * const threads = await prisma.thread.findMany({ take: 10 })
     * 
     * // Only select the `ticketNumber`
     * const threadWithTicketNumberOnly = await prisma.thread.findMany({ select: { ticketNumber: true } })
     * 
    **/
    findMany<T extends ThreadFindManyArgs>(
      args?: SelectSubset<T, ThreadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Thread>>, PrismaPromise<Array<ThreadGetPayload<T>>>>

    /**
     * Create a Thread.
     * @param {ThreadCreateArgs} args - Arguments to create a Thread.
     * @example
     * // Create one Thread
     * const Thread = await prisma.thread.create({
     *   data: {
     *     // ... data to create a Thread
     *   }
     * })
     * 
    **/
    create<T extends ThreadCreateArgs>(
      args: SelectSubset<T, ThreadCreateArgs>
    ): CheckSelect<T, Prisma__ThreadClient<Thread>, Prisma__ThreadClient<ThreadGetPayload<T>>>

    /**
     * Create many Threads.
     *     @param {ThreadCreateManyArgs} args - Arguments to create many Threads.
     *     @example
     *     // Create many Threads
     *     const thread = await prisma.thread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThreadCreateManyArgs>(
      args?: SelectSubset<T, ThreadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Thread.
     * @param {ThreadDeleteArgs} args - Arguments to delete one Thread.
     * @example
     * // Delete one Thread
     * const Thread = await prisma.thread.delete({
     *   where: {
     *     // ... filter to delete one Thread
     *   }
     * })
     * 
    **/
    delete<T extends ThreadDeleteArgs>(
      args: SelectSubset<T, ThreadDeleteArgs>
    ): CheckSelect<T, Prisma__ThreadClient<Thread>, Prisma__ThreadClient<ThreadGetPayload<T>>>

    /**
     * Update one Thread.
     * @param {ThreadUpdateArgs} args - Arguments to update one Thread.
     * @example
     * // Update one Thread
     * const thread = await prisma.thread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThreadUpdateArgs>(
      args: SelectSubset<T, ThreadUpdateArgs>
    ): CheckSelect<T, Prisma__ThreadClient<Thread>, Prisma__ThreadClient<ThreadGetPayload<T>>>

    /**
     * Delete zero or more Threads.
     * @param {ThreadDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.thread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThreadDeleteManyArgs>(
      args?: SelectSubset<T, ThreadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThreadUpdateManyArgs>(
      args: SelectSubset<T, ThreadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Thread.
     * @param {ThreadUpsertArgs} args - Arguments to update or create a Thread.
     * @example
     * // Update or create a Thread
     * const thread = await prisma.thread.upsert({
     *   create: {
     *     // ... data to create a Thread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thread we want to update
     *   }
     * })
    **/
    upsert<T extends ThreadUpsertArgs>(
      args: SelectSubset<T, ThreadUpsertArgs>
    ): CheckSelect<T, Prisma__ThreadClient<Thread>, Prisma__ThreadClient<ThreadGetPayload<T>>>

    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.thread.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
    **/
    count<T extends ThreadCountArgs>(
      args?: Subset<T, ThreadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAggregateArgs>(args: Subset<T, ThreadAggregateArgs>): PrismaPromise<GetThreadAggregateType<T>>

    /**
     * Group by Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadGroupByArgs['orderBy'] }
        : { orderBy?: ThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Thread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThreadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    DiscordMessage<T extends DiscordMessageFindManyArgs = {}>(args?: Subset<T, DiscordMessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DiscordMessage>>, PrismaPromise<Array<DiscordMessageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Thread findUnique
   */
  export type ThreadFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * Throw an Error if a Thread can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Thread to fetch.
     * 
    **/
    where: ThreadWhereUniqueInput
  }


  /**
   * Thread findFirst
   */
  export type ThreadFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * Throw an Error if a Thread can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Thread to fetch.
     * 
    **/
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     * 
    **/
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     * 
    **/
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     * 
    **/
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }


  /**
   * Thread findMany
   */
  export type ThreadFindManyArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * Filter, which Threads to fetch.
     * 
    **/
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     * 
    **/
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Threads.
     * 
    **/
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }


  /**
   * Thread create
   */
  export type ThreadCreateArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * The data needed to create a Thread.
     * 
    **/
    data: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
  }


  /**
   * Thread createMany
   */
  export type ThreadCreateManyArgs = {
    /**
     * The data used to create many Threads.
     * 
    **/
    data: Enumerable<ThreadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Thread update
   */
  export type ThreadUpdateArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * The data needed to update a Thread.
     * 
    **/
    data: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
    /**
     * Choose, which Thread to update.
     * 
    **/
    where: ThreadWhereUniqueInput
  }


  /**
   * Thread updateMany
   */
  export type ThreadUpdateManyArgs = {
    /**
     * The data used to update Threads.
     * 
    **/
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     * 
    **/
    where?: ThreadWhereInput
  }


  /**
   * Thread upsert
   */
  export type ThreadUpsertArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * The filter to search for the Thread to update in case it exists.
     * 
    **/
    where: ThreadWhereUniqueInput
    /**
     * In case the Thread found by the `where` argument doesn't exist, create a new Thread with this data.
     * 
    **/
    create: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
    /**
     * In case the Thread was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
  }


  /**
   * Thread delete
   */
  export type ThreadDeleteArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
    /**
     * Filter which Thread to delete.
     * 
    **/
    where: ThreadWhereUniqueInput
  }


  /**
   * Thread deleteMany
   */
  export type ThreadDeleteManyArgs = {
    /**
     * Filter which Threads to delete
     * 
    **/
    where?: ThreadWhereInput
  }


  /**
   * Thread without action
   */
  export type ThreadArgs = {
    /**
     * Select specific fields to fetch from the Thread
     * 
    **/
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ThreadInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    discordBotAuth: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    discordBotAuth: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    discordBotAuth: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    discordBotAuth?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    discordBotAuth?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    discordBotAuth?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    discordBotAuth: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    discordBotAuth?: boolean
    Feature?: boolean | FeatureFindManyArgs
    FeatureRequest?: boolean | FeatureRequestFindManyArgs
    NotionAuth?: boolean | NotionAuthFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    Feature?: boolean | FeatureFindManyArgs
    FeatureRequest?: boolean | FeatureRequestFindManyArgs
    NotionAuth?: boolean | NotionAuthFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Feature' ? Array < FeatureGetPayload<S['include'][P]>>  :
        P extends 'FeatureRequest' ? Array < FeatureRequestGetPayload<S['include'][P]>>  :
        P extends 'NotionAuth' ? Array < NotionAuthGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Feature' ? Array < FeatureGetPayload<S['select'][P]>>  :
        P extends 'FeatureRequest' ? Array < FeatureRequestGetPayload<S['select'][P]>>  :
        P extends 'NotionAuth' ? Array < NotionAuthGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Feature<T extends FeatureFindManyArgs = {}>(args?: Subset<T, FeatureFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Feature>>, PrismaPromise<Array<FeatureGetPayload<T>>>>;

    FeatureRequest<T extends FeatureRequestFindManyArgs = {}>(args?: Subset<T, FeatureRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FeatureRequest>>, PrismaPromise<Array<FeatureRequestGetPayload<T>>>>;

    NotionAuth<T extends NotionAuthFindManyArgs = {}>(args?: Subset<T, NotionAuthFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NotionAuth>>, PrismaPromise<Array<NotionAuthGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const DiscordMessageScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    messageUser: 'messageUser',
    messageContent: 'messageContent'
  };

  export type DiscordMessageScalarFieldEnum = (typeof DiscordMessageScalarFieldEnum)[keyof typeof DiscordMessageScalarFieldEnum]


  export const DiscordUserScalarFieldEnum: {
    username: 'username',
    notionAuthId: 'notionAuthId'
  };

  export type DiscordUserScalarFieldEnum = (typeof DiscordUserScalarFieldEnum)[keyof typeof DiscordUserScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    userId: 'userId',
    columnState: 'columnState',
    rankState: 'rankState',
    isSearched: 'isSearched'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const FeatureRequestScalarFieldEnum: {
    fr_id: 'fr_id',
    message_id: 'message_id',
    message: 'message',
    created_at: 'created_at',
    author: 'author',
    label: 'label',
    fr: 'fr',
    kmeans_labels: 'kmeans_labels',
    userId: 'userId'
  };

  export type FeatureRequestScalarFieldEnum = (typeof FeatureRequestScalarFieldEnum)[keyof typeof FeatureRequestScalarFieldEnum]


  export const FeatureRequestMapScalarFieldEnum: {
    featureId: 'featureId',
    featureRequestId: 'featureRequestId',
    pinned: 'pinned',
    cluster: 'cluster'
  };

  export type FeatureRequestMapScalarFieldEnum = (typeof FeatureRequestMapScalarFieldEnum)[keyof typeof FeatureRequestMapScalarFieldEnum]


  export const NotionAuthScalarFieldEnum: {
    botId: 'botId',
    accessToken: 'accessToken',
    owner: 'owner',
    duplicatedTemplateId: 'duplicatedTemplateId',
    workspaceIcon: 'workspaceIcon',
    workspaceId: 'workspaceId',
    workspaceName: 'workspaceName',
    userId: 'userId',
    guildName: 'guildName'
  };

  export type NotionAuthScalarFieldEnum = (typeof NotionAuthScalarFieldEnum)[keyof typeof NotionAuthScalarFieldEnum]


  export const ThreadScalarFieldEnum: {
    ticketNumber: 'ticketNumber',
    threadName: 'threadName',
    createdTime: 'createdTime',
    threadLink: 'threadLink',
    bugOverview: 'bugOverview'
  };

  export type ThreadScalarFieldEnum = (typeof ThreadScalarFieldEnum)[keyof typeof ThreadScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    discordBotAuth: 'discordBotAuth'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type DiscordMessageWhereInput = {
    AND?: Enumerable<DiscordMessageWhereInput>
    OR?: Enumerable<DiscordMessageWhereInput>
    NOT?: Enumerable<DiscordMessageWhereInput>
    id?: IntFilter | number
    threadId?: StringFilter | string
    messageUser?: StringFilter | string
    messageContent?: StringFilter | string
    Thread?: XOR<ThreadRelationFilter, ThreadWhereInput>
  }

  export type DiscordMessageOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    messageUser?: SortOrder
    messageContent?: SortOrder
    Thread?: ThreadOrderByWithRelationInput
  }

  export type DiscordMessageWhereUniqueInput = {
    id?: number
  }

  export type DiscordMessageOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    messageUser?: SortOrder
    messageContent?: SortOrder
    _count?: DiscordMessageCountOrderByAggregateInput
    _avg?: DiscordMessageAvgOrderByAggregateInput
    _max?: DiscordMessageMaxOrderByAggregateInput
    _min?: DiscordMessageMinOrderByAggregateInput
    _sum?: DiscordMessageSumOrderByAggregateInput
  }

  export type DiscordMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscordMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscordMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscordMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    threadId?: StringWithAggregatesFilter | string
    messageUser?: StringWithAggregatesFilter | string
    messageContent?: StringWithAggregatesFilter | string
  }

  export type DiscordUserWhereInput = {
    AND?: Enumerable<DiscordUserWhereInput>
    OR?: Enumerable<DiscordUserWhereInput>
    NOT?: Enumerable<DiscordUserWhereInput>
    username?: StringFilter | string
    notionAuthId?: StringFilter | string
    NotionAuth?: XOR<NotionAuthRelationFilter, NotionAuthWhereInput>
  }

  export type DiscordUserOrderByWithRelationInput = {
    username?: SortOrder
    notionAuthId?: SortOrder
    NotionAuth?: NotionAuthOrderByWithRelationInput
  }

  export type DiscordUserWhereUniqueInput = {
    username?: string
  }

  export type DiscordUserOrderByWithAggregationInput = {
    username?: SortOrder
    notionAuthId?: SortOrder
    _count?: DiscordUserCountOrderByAggregateInput
    _max?: DiscordUserMaxOrderByAggregateInput
    _min?: DiscordUserMinOrderByAggregateInput
  }

  export type DiscordUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscordUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscordUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscordUserScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    notionAuthId?: StringWithAggregatesFilter | string
  }

  export type FeatureWhereInput = {
    AND?: Enumerable<FeatureWhereInput>
    OR?: Enumerable<FeatureWhereInput>
    NOT?: Enumerable<FeatureWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    userId?: StringFilter | string
    columnState?: IntFilter | number
    rankState?: IntFilter | number
    isSearched?: BoolFilter | boolean
    User?: XOR<UserRelationFilter, UserWhereInput>
    FeatureRequestMap?: FeatureRequestMapListRelationFilter
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
    isSearched?: SortOrder
    User?: UserOrderByWithRelationInput
    FeatureRequestMap?: FeatureRequestMapOrderByRelationAggregateInput
  }

  export type FeatureWhereUniqueInput = {
    id?: number
  }

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
    isSearched?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _avg?: FeatureAvgOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
    _sum?: FeatureSumOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeatureScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeatureScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeatureScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    columnState?: IntWithAggregatesFilter | number
    rankState?: IntWithAggregatesFilter | number
    isSearched?: BoolWithAggregatesFilter | boolean
  }

  export type FeatureRequestWhereInput = {
    AND?: Enumerable<FeatureRequestWhereInput>
    OR?: Enumerable<FeatureRequestWhereInput>
    NOT?: Enumerable<FeatureRequestWhereInput>
    fr_id?: StringFilter | string
    message_id?: StringFilter | string
    message?: StringFilter | string
    created_at?: StringFilter | string
    author?: StringFilter | string
    label?: StringFilter | string
    fr?: StringFilter | string
    kmeans_labels?: IntFilter | number
    userId?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    FeatureRequestMap?: FeatureRequestMapListRelationFilter
  }

  export type FeatureRequestOrderByWithRelationInput = {
    fr_id?: SortOrder
    message_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    author?: SortOrder
    label?: SortOrder
    fr?: SortOrder
    kmeans_labels?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
    FeatureRequestMap?: FeatureRequestMapOrderByRelationAggregateInput
  }

  export type FeatureRequestWhereUniqueInput = {
    fr_id?: string
  }

  export type FeatureRequestOrderByWithAggregationInput = {
    fr_id?: SortOrder
    message_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    author?: SortOrder
    label?: SortOrder
    fr?: SortOrder
    kmeans_labels?: SortOrder
    userId?: SortOrder
    _count?: FeatureRequestCountOrderByAggregateInput
    _avg?: FeatureRequestAvgOrderByAggregateInput
    _max?: FeatureRequestMaxOrderByAggregateInput
    _min?: FeatureRequestMinOrderByAggregateInput
    _sum?: FeatureRequestSumOrderByAggregateInput
  }

  export type FeatureRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeatureRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeatureRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeatureRequestScalarWhereWithAggregatesInput>
    fr_id?: StringWithAggregatesFilter | string
    message_id?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    created_at?: StringWithAggregatesFilter | string
    author?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    fr?: StringWithAggregatesFilter | string
    kmeans_labels?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
  }

  export type FeatureRequestMapWhereInput = {
    AND?: Enumerable<FeatureRequestMapWhereInput>
    OR?: Enumerable<FeatureRequestMapWhereInput>
    NOT?: Enumerable<FeatureRequestMapWhereInput>
    featureId?: IntFilter | number
    featureRequestId?: StringFilter | string
    pinned?: BoolFilter | boolean
    cluster?: IntFilter | number
    Feature?: XOR<FeatureRelationFilter, FeatureWhereInput>
    FeatureRequest?: XOR<FeatureRequestRelationFilter, FeatureRequestWhereInput>
  }

  export type FeatureRequestMapOrderByWithRelationInput = {
    featureId?: SortOrder
    featureRequestId?: SortOrder
    pinned?: SortOrder
    cluster?: SortOrder
    Feature?: FeatureOrderByWithRelationInput
    FeatureRequest?: FeatureRequestOrderByWithRelationInput
  }

  export type FeatureRequestMapWhereUniqueInput = {
    featureId_featureRequestId?: FeatureRequestMapFeatureIdFeatureRequestIdCompoundUniqueInput
  }

  export type FeatureRequestMapOrderByWithAggregationInput = {
    featureId?: SortOrder
    featureRequestId?: SortOrder
    pinned?: SortOrder
    cluster?: SortOrder
    _count?: FeatureRequestMapCountOrderByAggregateInput
    _avg?: FeatureRequestMapAvgOrderByAggregateInput
    _max?: FeatureRequestMapMaxOrderByAggregateInput
    _min?: FeatureRequestMapMinOrderByAggregateInput
    _sum?: FeatureRequestMapSumOrderByAggregateInput
  }

  export type FeatureRequestMapScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeatureRequestMapScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeatureRequestMapScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeatureRequestMapScalarWhereWithAggregatesInput>
    featureId?: IntWithAggregatesFilter | number
    featureRequestId?: StringWithAggregatesFilter | string
    pinned?: BoolWithAggregatesFilter | boolean
    cluster?: IntWithAggregatesFilter | number
  }

  export type NotionAuthWhereInput = {
    AND?: Enumerable<NotionAuthWhereInput>
    OR?: Enumerable<NotionAuthWhereInput>
    NOT?: Enumerable<NotionAuthWhereInput>
    botId?: StringFilter | string
    accessToken?: StringFilter | string
    owner?: StringFilter | string
    duplicatedTemplateId?: StringFilter | string
    workspaceIcon?: StringFilter | string
    workspaceId?: StringFilter | string
    workspaceName?: StringFilter | string
    userId?: StringFilter | string
    guildName?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    DiscordUser?: DiscordUserListRelationFilter
  }

  export type NotionAuthOrderByWithRelationInput = {
    botId?: SortOrder
    accessToken?: SortOrder
    owner?: SortOrder
    duplicatedTemplateId?: SortOrder
    workspaceIcon?: SortOrder
    workspaceId?: SortOrder
    workspaceName?: SortOrder
    userId?: SortOrder
    guildName?: SortOrder
    User?: UserOrderByWithRelationInput
    DiscordUser?: DiscordUserOrderByRelationAggregateInput
  }

  export type NotionAuthWhereUniqueInput = {
    botId?: string
  }

  export type NotionAuthOrderByWithAggregationInput = {
    botId?: SortOrder
    accessToken?: SortOrder
    owner?: SortOrder
    duplicatedTemplateId?: SortOrder
    workspaceIcon?: SortOrder
    workspaceId?: SortOrder
    workspaceName?: SortOrder
    userId?: SortOrder
    guildName?: SortOrder
    _count?: NotionAuthCountOrderByAggregateInput
    _max?: NotionAuthMaxOrderByAggregateInput
    _min?: NotionAuthMinOrderByAggregateInput
  }

  export type NotionAuthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotionAuthScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotionAuthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotionAuthScalarWhereWithAggregatesInput>
    botId?: StringWithAggregatesFilter | string
    accessToken?: StringWithAggregatesFilter | string
    owner?: StringWithAggregatesFilter | string
    duplicatedTemplateId?: StringWithAggregatesFilter | string
    workspaceIcon?: StringWithAggregatesFilter | string
    workspaceId?: StringWithAggregatesFilter | string
    workspaceName?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    guildName?: StringNullableWithAggregatesFilter | string | null
  }

  export type ThreadWhereInput = {
    AND?: Enumerable<ThreadWhereInput>
    OR?: Enumerable<ThreadWhereInput>
    NOT?: Enumerable<ThreadWhereInput>
    ticketNumber?: StringFilter | string
    threadName?: StringFilter | string
    createdTime?: StringFilter | string
    threadLink?: StringFilter | string
    bugOverview?: StringFilter | string
    DiscordMessage?: DiscordMessageListRelationFilter
  }

  export type ThreadOrderByWithRelationInput = {
    ticketNumber?: SortOrder
    threadName?: SortOrder
    createdTime?: SortOrder
    threadLink?: SortOrder
    bugOverview?: SortOrder
    DiscordMessage?: DiscordMessageOrderByRelationAggregateInput
  }

  export type ThreadWhereUniqueInput = {
    ticketNumber?: string
  }

  export type ThreadOrderByWithAggregationInput = {
    ticketNumber?: SortOrder
    threadName?: SortOrder
    createdTime?: SortOrder
    threadLink?: SortOrder
    bugOverview?: SortOrder
    _count?: ThreadCountOrderByAggregateInput
    _max?: ThreadMaxOrderByAggregateInput
    _min?: ThreadMinOrderByAggregateInput
  }

  export type ThreadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ThreadScalarWhereWithAggregatesInput>
    OR?: Enumerable<ThreadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ThreadScalarWhereWithAggregatesInput>
    ticketNumber?: StringWithAggregatesFilter | string
    threadName?: StringWithAggregatesFilter | string
    createdTime?: StringWithAggregatesFilter | string
    threadLink?: StringWithAggregatesFilter | string
    bugOverview?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    discordBotAuth?: BoolFilter | boolean
    Feature?: FeatureListRelationFilter
    FeatureRequest?: FeatureRequestListRelationFilter
    NotionAuth?: NotionAuthListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    discordBotAuth?: SortOrder
    Feature?: FeatureOrderByRelationAggregateInput
    FeatureRequest?: FeatureRequestOrderByRelationAggregateInput
    NotionAuth?: NotionAuthOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    discordBotAuth?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    discordBotAuth?: BoolWithAggregatesFilter | boolean
  }

  export type DiscordMessageCreateInput = {
    messageUser: string
    messageContent: string
    Thread: ThreadCreateNestedOneWithoutDiscordMessageInput
  }

  export type DiscordMessageUncheckedCreateInput = {
    id?: number
    threadId: string
    messageUser: string
    messageContent: string
  }

  export type DiscordMessageUpdateInput = {
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
    Thread?: ThreadUpdateOneRequiredWithoutDiscordMessageInput
  }

  export type DiscordMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    threadId?: StringFieldUpdateOperationsInput | string
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordMessageCreateManyInput = {
    id?: number
    threadId: string
    messageUser: string
    messageContent: string
  }

  export type DiscordMessageUpdateManyMutationInput = {
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    threadId?: StringFieldUpdateOperationsInput | string
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordUserCreateInput = {
    username: string
    NotionAuth: NotionAuthCreateNestedOneWithoutDiscordUserInput
  }

  export type DiscordUserUncheckedCreateInput = {
    username: string
    notionAuthId: string
  }

  export type DiscordUserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    NotionAuth?: NotionAuthUpdateOneRequiredWithoutDiscordUserInput
  }

  export type DiscordUserUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    notionAuthId?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordUserCreateManyInput = {
    username: string
    notionAuthId: string
  }

  export type DiscordUserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordUserUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    notionAuthId?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureCreateInput = {
    title: string
    description?: string
    columnState: number
    rankState: number
    isSearched?: boolean
    User: UserCreateNestedOneWithoutFeatureInput
    FeatureRequestMap?: FeatureRequestMapCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateInput = {
    id?: number
    title: string
    description?: string
    userId: string
    columnState: number
    rankState: number
    isSearched?: boolean
    FeatureRequestMap?: FeatureRequestMapUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutFeatureInput
    FeatureRequestMap?: FeatureRequestMapUpdateManyWithoutFeatureInput
  }

  export type FeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
    FeatureRequestMap?: FeatureRequestMapUncheckedUpdateManyWithoutFeatureInput
  }

  export type FeatureCreateManyInput = {
    id?: number
    title: string
    description?: string
    userId: string
    columnState: number
    rankState: number
    isSearched?: boolean
  }

  export type FeatureUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureRequestCreateInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    User: UserCreateNestedOneWithoutFeatureRequestInput
    FeatureRequestMap?: FeatureRequestMapCreateNestedManyWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedCreateInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    userId: string
    FeatureRequestMap?: FeatureRequestMapUncheckedCreateNestedManyWithoutFeatureRequestInput
  }

  export type FeatureRequestUpdateInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutFeatureRequestInput
    FeatureRequestMap?: FeatureRequestMapUpdateManyWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedUpdateInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    FeatureRequestMap?: FeatureRequestMapUncheckedUpdateManyWithoutFeatureRequestInput
  }

  export type FeatureRequestCreateManyInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    userId: string
  }

  export type FeatureRequestUpdateManyMutationInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
  }

  export type FeatureRequestUncheckedUpdateManyInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureRequestMapCreateInput = {
    pinned?: boolean
    cluster?: number
    Feature: FeatureCreateNestedOneWithoutFeatureRequestMapInput
    FeatureRequest: FeatureRequestCreateNestedOneWithoutFeatureRequestMapInput
  }

  export type FeatureRequestMapUncheckedCreateInput = {
    featureId: number
    featureRequestId: string
    pinned?: boolean
    cluster?: number
  }

  export type FeatureRequestMapUpdateInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
    Feature?: FeatureUpdateOneRequiredWithoutFeatureRequestMapInput
    FeatureRequest?: FeatureRequestUpdateOneRequiredWithoutFeatureRequestMapInput
  }

  export type FeatureRequestMapUncheckedUpdateInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    featureRequestId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
  }

  export type FeatureRequestMapCreateManyInput = {
    featureId: number
    featureRequestId: string
    pinned?: boolean
    cluster?: number
  }

  export type FeatureRequestMapUpdateManyMutationInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
  }

  export type FeatureRequestMapUncheckedUpdateManyInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    featureRequestId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
  }

  export type NotionAuthCreateInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    guildName?: string | null
    User: UserCreateNestedOneWithoutNotionAuthInput
    DiscordUser?: DiscordUserCreateNestedManyWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedCreateInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    userId: string
    guildName?: string | null
    DiscordUser?: DiscordUserUncheckedCreateNestedManyWithoutNotionAuthInput
  }

  export type NotionAuthUpdateInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutNotionAuthInput
    DiscordUser?: DiscordUserUpdateManyWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedUpdateInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
    DiscordUser?: DiscordUserUncheckedUpdateManyWithoutNotionAuthInput
  }

  export type NotionAuthCreateManyInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    userId: string
    guildName?: string | null
  }

  export type NotionAuthUpdateManyMutationInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotionAuthUncheckedUpdateManyInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadCreateInput = {
    ticketNumber: string
    threadName: string
    createdTime: string
    threadLink: string
    bugOverview: string
    DiscordMessage?: DiscordMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateInput = {
    ticketNumber: string
    threadName: string
    createdTime: string
    threadLink: string
    bugOverview: string
    DiscordMessage?: DiscordMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadUpdateInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    threadName?: StringFieldUpdateOperationsInput | string
    createdTime?: StringFieldUpdateOperationsInput | string
    threadLink?: StringFieldUpdateOperationsInput | string
    bugOverview?: StringFieldUpdateOperationsInput | string
    DiscordMessage?: DiscordMessageUpdateManyWithoutThreadInput
  }

  export type ThreadUncheckedUpdateInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    threadName?: StringFieldUpdateOperationsInput | string
    createdTime?: StringFieldUpdateOperationsInput | string
    threadLink?: StringFieldUpdateOperationsInput | string
    bugOverview?: StringFieldUpdateOperationsInput | string
    DiscordMessage?: DiscordMessageUncheckedUpdateManyWithoutThreadInput
  }

  export type ThreadCreateManyInput = {
    ticketNumber: string
    threadName: string
    createdTime: string
    threadLink: string
    bugOverview: string
  }

  export type ThreadUpdateManyMutationInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    threadName?: StringFieldUpdateOperationsInput | string
    createdTime?: StringFieldUpdateOperationsInput | string
    threadLink?: StringFieldUpdateOperationsInput | string
    bugOverview?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadUncheckedUpdateManyInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    threadName?: StringFieldUpdateOperationsInput | string
    createdTime?: StringFieldUpdateOperationsInput | string
    threadLink?: StringFieldUpdateOperationsInput | string
    bugOverview?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    Feature?: FeatureCreateNestedManyWithoutUserInput
    FeatureRequest?: FeatureRequestCreateNestedManyWithoutUserInput
    NotionAuth?: NotionAuthCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    Feature?: FeatureUncheckedCreateNestedManyWithoutUserInput
    FeatureRequest?: FeatureRequestUncheckedCreateNestedManyWithoutUserInput
    NotionAuth?: NotionAuthUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    Feature?: FeatureUpdateManyWithoutUserInput
    FeatureRequest?: FeatureRequestUpdateManyWithoutUserInput
    NotionAuth?: NotionAuthUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    Feature?: FeatureUncheckedUpdateManyWithoutUserInput
    FeatureRequest?: FeatureRequestUncheckedUpdateManyWithoutUserInput
    NotionAuth?: NotionAuthUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    discordBotAuth?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type ThreadRelationFilter = {
    is?: ThreadWhereInput
    isNot?: ThreadWhereInput
  }

  export type DiscordMessageCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    messageUser?: SortOrder
    messageContent?: SortOrder
  }

  export type DiscordMessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiscordMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    messageUser?: SortOrder
    messageContent?: SortOrder
  }

  export type DiscordMessageMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    messageUser?: SortOrder
    messageContent?: SortOrder
  }

  export type DiscordMessageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NotionAuthRelationFilter = {
    is?: NotionAuthWhereInput
    isNot?: NotionAuthWhereInput
  }

  export type DiscordUserCountOrderByAggregateInput = {
    username?: SortOrder
    notionAuthId?: SortOrder
  }

  export type DiscordUserMaxOrderByAggregateInput = {
    username?: SortOrder
    notionAuthId?: SortOrder
  }

  export type DiscordUserMinOrderByAggregateInput = {
    username?: SortOrder
    notionAuthId?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FeatureRequestMapListRelationFilter = {
    every?: FeatureRequestMapWhereInput
    some?: FeatureRequestMapWhereInput
    none?: FeatureRequestMapWhereInput
  }

  export type FeatureRequestMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
    isSearched?: SortOrder
  }

  export type FeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
    isSearched?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
    isSearched?: SortOrder
  }

  export type FeatureSumOrderByAggregateInput = {
    id?: SortOrder
    columnState?: SortOrder
    rankState?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type FeatureRequestCountOrderByAggregateInput = {
    fr_id?: SortOrder
    message_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    author?: SortOrder
    label?: SortOrder
    fr?: SortOrder
    kmeans_labels?: SortOrder
    userId?: SortOrder
  }

  export type FeatureRequestAvgOrderByAggregateInput = {
    kmeans_labels?: SortOrder
  }

  export type FeatureRequestMaxOrderByAggregateInput = {
    fr_id?: SortOrder
    message_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    author?: SortOrder
    label?: SortOrder
    fr?: SortOrder
    kmeans_labels?: SortOrder
    userId?: SortOrder
  }

  export type FeatureRequestMinOrderByAggregateInput = {
    fr_id?: SortOrder
    message_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    author?: SortOrder
    label?: SortOrder
    fr?: SortOrder
    kmeans_labels?: SortOrder
    userId?: SortOrder
  }

  export type FeatureRequestSumOrderByAggregateInput = {
    kmeans_labels?: SortOrder
  }

  export type FeatureRelationFilter = {
    is?: FeatureWhereInput
    isNot?: FeatureWhereInput
  }

  export type FeatureRequestRelationFilter = {
    is?: FeatureRequestWhereInput
    isNot?: FeatureRequestWhereInput
  }

  export type FeatureRequestMapFeatureIdFeatureRequestIdCompoundUniqueInput = {
    featureId: number
    featureRequestId: string
  }

  export type FeatureRequestMapCountOrderByAggregateInput = {
    featureId?: SortOrder
    featureRequestId?: SortOrder
    pinned?: SortOrder
    cluster?: SortOrder
  }

  export type FeatureRequestMapAvgOrderByAggregateInput = {
    featureId?: SortOrder
    cluster?: SortOrder
  }

  export type FeatureRequestMapMaxOrderByAggregateInput = {
    featureId?: SortOrder
    featureRequestId?: SortOrder
    pinned?: SortOrder
    cluster?: SortOrder
  }

  export type FeatureRequestMapMinOrderByAggregateInput = {
    featureId?: SortOrder
    featureRequestId?: SortOrder
    pinned?: SortOrder
    cluster?: SortOrder
  }

  export type FeatureRequestMapSumOrderByAggregateInput = {
    featureId?: SortOrder
    cluster?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DiscordUserListRelationFilter = {
    every?: DiscordUserWhereInput
    some?: DiscordUserWhereInput
    none?: DiscordUserWhereInput
  }

  export type DiscordUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotionAuthCountOrderByAggregateInput = {
    botId?: SortOrder
    accessToken?: SortOrder
    owner?: SortOrder
    duplicatedTemplateId?: SortOrder
    workspaceIcon?: SortOrder
    workspaceId?: SortOrder
    workspaceName?: SortOrder
    userId?: SortOrder
    guildName?: SortOrder
  }

  export type NotionAuthMaxOrderByAggregateInput = {
    botId?: SortOrder
    accessToken?: SortOrder
    owner?: SortOrder
    duplicatedTemplateId?: SortOrder
    workspaceIcon?: SortOrder
    workspaceId?: SortOrder
    workspaceName?: SortOrder
    userId?: SortOrder
    guildName?: SortOrder
  }

  export type NotionAuthMinOrderByAggregateInput = {
    botId?: SortOrder
    accessToken?: SortOrder
    owner?: SortOrder
    duplicatedTemplateId?: SortOrder
    workspaceIcon?: SortOrder
    workspaceId?: SortOrder
    workspaceName?: SortOrder
    userId?: SortOrder
    guildName?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DiscordMessageListRelationFilter = {
    every?: DiscordMessageWhereInput
    some?: DiscordMessageWhereInput
    none?: DiscordMessageWhereInput
  }

  export type DiscordMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadCountOrderByAggregateInput = {
    ticketNumber?: SortOrder
    threadName?: SortOrder
    createdTime?: SortOrder
    threadLink?: SortOrder
    bugOverview?: SortOrder
  }

  export type ThreadMaxOrderByAggregateInput = {
    ticketNumber?: SortOrder
    threadName?: SortOrder
    createdTime?: SortOrder
    threadLink?: SortOrder
    bugOverview?: SortOrder
  }

  export type ThreadMinOrderByAggregateInput = {
    ticketNumber?: SortOrder
    threadName?: SortOrder
    createdTime?: SortOrder
    threadLink?: SortOrder
    bugOverview?: SortOrder
  }

  export type FeatureListRelationFilter = {
    every?: FeatureWhereInput
    some?: FeatureWhereInput
    none?: FeatureWhereInput
  }

  export type FeatureRequestListRelationFilter = {
    every?: FeatureRequestWhereInput
    some?: FeatureRequestWhereInput
    none?: FeatureRequestWhereInput
  }

  export type NotionAuthListRelationFilter = {
    every?: NotionAuthWhereInput
    some?: NotionAuthWhereInput
    none?: NotionAuthWhereInput
  }

  export type FeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotionAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    discordBotAuth?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    discordBotAuth?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    discordBotAuth?: SortOrder
  }

  export type ThreadCreateNestedOneWithoutDiscordMessageInput = {
    create?: XOR<ThreadCreateWithoutDiscordMessageInput, ThreadUncheckedCreateWithoutDiscordMessageInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutDiscordMessageInput
    connect?: ThreadWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ThreadUpdateOneRequiredWithoutDiscordMessageInput = {
    create?: XOR<ThreadCreateWithoutDiscordMessageInput, ThreadUncheckedCreateWithoutDiscordMessageInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutDiscordMessageInput
    upsert?: ThreadUpsertWithoutDiscordMessageInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<ThreadUpdateWithoutDiscordMessageInput, ThreadUncheckedUpdateWithoutDiscordMessageInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NotionAuthCreateNestedOneWithoutDiscordUserInput = {
    create?: XOR<NotionAuthCreateWithoutDiscordUserInput, NotionAuthUncheckedCreateWithoutDiscordUserInput>
    connectOrCreate?: NotionAuthCreateOrConnectWithoutDiscordUserInput
    connect?: NotionAuthWhereUniqueInput
  }

  export type NotionAuthUpdateOneRequiredWithoutDiscordUserInput = {
    create?: XOR<NotionAuthCreateWithoutDiscordUserInput, NotionAuthUncheckedCreateWithoutDiscordUserInput>
    connectOrCreate?: NotionAuthCreateOrConnectWithoutDiscordUserInput
    upsert?: NotionAuthUpsertWithoutDiscordUserInput
    connect?: NotionAuthWhereUniqueInput
    update?: XOR<NotionAuthUpdateWithoutDiscordUserInput, NotionAuthUncheckedUpdateWithoutDiscordUserInput>
  }

  export type UserCreateNestedOneWithoutFeatureInput = {
    create?: XOR<UserCreateWithoutFeatureInput, UserUncheckedCreateWithoutFeatureInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureInput
    connect?: UserWhereUniqueInput
  }

  export type FeatureRequestMapCreateNestedManyWithoutFeatureInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureInput>
    createMany?: FeatureRequestMapCreateManyFeatureInputEnvelope
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
  }

  export type FeatureRequestMapUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureInput>
    createMany?: FeatureRequestMapCreateManyFeatureInputEnvelope
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutFeatureInput = {
    create?: XOR<UserCreateWithoutFeatureInput, UserUncheckedCreateWithoutFeatureInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureInput
    upsert?: UserUpsertWithoutFeatureInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeatureInput, UserUncheckedUpdateWithoutFeatureInput>
  }

  export type FeatureRequestMapUpdateManyWithoutFeatureInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureInput>
    upsert?: Enumerable<FeatureRequestMapUpsertWithWhereUniqueWithoutFeatureInput>
    createMany?: FeatureRequestMapCreateManyFeatureInputEnvelope
    set?: Enumerable<FeatureRequestMapWhereUniqueInput>
    disconnect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    delete?: Enumerable<FeatureRequestMapWhereUniqueInput>
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    update?: Enumerable<FeatureRequestMapUpdateWithWhereUniqueWithoutFeatureInput>
    updateMany?: Enumerable<FeatureRequestMapUpdateManyWithWhereWithoutFeatureInput>
    deleteMany?: Enumerable<FeatureRequestMapScalarWhereInput>
  }

  export type FeatureRequestMapUncheckedUpdateManyWithoutFeatureInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureInput>
    upsert?: Enumerable<FeatureRequestMapUpsertWithWhereUniqueWithoutFeatureInput>
    createMany?: FeatureRequestMapCreateManyFeatureInputEnvelope
    set?: Enumerable<FeatureRequestMapWhereUniqueInput>
    disconnect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    delete?: Enumerable<FeatureRequestMapWhereUniqueInput>
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    update?: Enumerable<FeatureRequestMapUpdateWithWhereUniqueWithoutFeatureInput>
    updateMany?: Enumerable<FeatureRequestMapUpdateManyWithWhereWithoutFeatureInput>
    deleteMany?: Enumerable<FeatureRequestMapScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutFeatureRequestInput = {
    create?: XOR<UserCreateWithoutFeatureRequestInput, UserUncheckedCreateWithoutFeatureRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureRequestInput
    connect?: UserWhereUniqueInput
  }

  export type FeatureRequestMapCreateNestedManyWithoutFeatureRequestInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureRequestInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureRequestInput>
    createMany?: FeatureRequestMapCreateManyFeatureRequestInputEnvelope
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
  }

  export type FeatureRequestMapUncheckedCreateNestedManyWithoutFeatureRequestInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureRequestInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureRequestInput>
    createMany?: FeatureRequestMapCreateManyFeatureRequestInputEnvelope
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutFeatureRequestInput = {
    create?: XOR<UserCreateWithoutFeatureRequestInput, UserUncheckedCreateWithoutFeatureRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureRequestInput
    upsert?: UserUpsertWithoutFeatureRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeatureRequestInput, UserUncheckedUpdateWithoutFeatureRequestInput>
  }

  export type FeatureRequestMapUpdateManyWithoutFeatureRequestInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureRequestInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureRequestInput>
    upsert?: Enumerable<FeatureRequestMapUpsertWithWhereUniqueWithoutFeatureRequestInput>
    createMany?: FeatureRequestMapCreateManyFeatureRequestInputEnvelope
    set?: Enumerable<FeatureRequestMapWhereUniqueInput>
    disconnect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    delete?: Enumerable<FeatureRequestMapWhereUniqueInput>
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    update?: Enumerable<FeatureRequestMapUpdateWithWhereUniqueWithoutFeatureRequestInput>
    updateMany?: Enumerable<FeatureRequestMapUpdateManyWithWhereWithoutFeatureRequestInput>
    deleteMany?: Enumerable<FeatureRequestMapScalarWhereInput>
  }

  export type FeatureRequestMapUncheckedUpdateManyWithoutFeatureRequestInput = {
    create?: XOR<Enumerable<FeatureRequestMapCreateWithoutFeatureRequestInput>, Enumerable<FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput>>
    connectOrCreate?: Enumerable<FeatureRequestMapCreateOrConnectWithoutFeatureRequestInput>
    upsert?: Enumerable<FeatureRequestMapUpsertWithWhereUniqueWithoutFeatureRequestInput>
    createMany?: FeatureRequestMapCreateManyFeatureRequestInputEnvelope
    set?: Enumerable<FeatureRequestMapWhereUniqueInput>
    disconnect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    delete?: Enumerable<FeatureRequestMapWhereUniqueInput>
    connect?: Enumerable<FeatureRequestMapWhereUniqueInput>
    update?: Enumerable<FeatureRequestMapUpdateWithWhereUniqueWithoutFeatureRequestInput>
    updateMany?: Enumerable<FeatureRequestMapUpdateManyWithWhereWithoutFeatureRequestInput>
    deleteMany?: Enumerable<FeatureRequestMapScalarWhereInput>
  }

  export type FeatureCreateNestedOneWithoutFeatureRequestMapInput = {
    create?: XOR<FeatureCreateWithoutFeatureRequestMapInput, FeatureUncheckedCreateWithoutFeatureRequestMapInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutFeatureRequestMapInput
    connect?: FeatureWhereUniqueInput
  }

  export type FeatureRequestCreateNestedOneWithoutFeatureRequestMapInput = {
    create?: XOR<FeatureRequestCreateWithoutFeatureRequestMapInput, FeatureRequestUncheckedCreateWithoutFeatureRequestMapInput>
    connectOrCreate?: FeatureRequestCreateOrConnectWithoutFeatureRequestMapInput
    connect?: FeatureRequestWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutFeatureRequestMapInput = {
    create?: XOR<FeatureCreateWithoutFeatureRequestMapInput, FeatureUncheckedCreateWithoutFeatureRequestMapInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutFeatureRequestMapInput
    upsert?: FeatureUpsertWithoutFeatureRequestMapInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<FeatureUpdateWithoutFeatureRequestMapInput, FeatureUncheckedUpdateWithoutFeatureRequestMapInput>
  }

  export type FeatureRequestUpdateOneRequiredWithoutFeatureRequestMapInput = {
    create?: XOR<FeatureRequestCreateWithoutFeatureRequestMapInput, FeatureRequestUncheckedCreateWithoutFeatureRequestMapInput>
    connectOrCreate?: FeatureRequestCreateOrConnectWithoutFeatureRequestMapInput
    upsert?: FeatureRequestUpsertWithoutFeatureRequestMapInput
    connect?: FeatureRequestWhereUniqueInput
    update?: XOR<FeatureRequestUpdateWithoutFeatureRequestMapInput, FeatureRequestUncheckedUpdateWithoutFeatureRequestMapInput>
  }

  export type UserCreateNestedOneWithoutNotionAuthInput = {
    create?: XOR<UserCreateWithoutNotionAuthInput, UserUncheckedCreateWithoutNotionAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotionAuthInput
    connect?: UserWhereUniqueInput
  }

  export type DiscordUserCreateNestedManyWithoutNotionAuthInput = {
    create?: XOR<Enumerable<DiscordUserCreateWithoutNotionAuthInput>, Enumerable<DiscordUserUncheckedCreateWithoutNotionAuthInput>>
    connectOrCreate?: Enumerable<DiscordUserCreateOrConnectWithoutNotionAuthInput>
    createMany?: DiscordUserCreateManyNotionAuthInputEnvelope
    connect?: Enumerable<DiscordUserWhereUniqueInput>
  }

  export type DiscordUserUncheckedCreateNestedManyWithoutNotionAuthInput = {
    create?: XOR<Enumerable<DiscordUserCreateWithoutNotionAuthInput>, Enumerable<DiscordUserUncheckedCreateWithoutNotionAuthInput>>
    connectOrCreate?: Enumerable<DiscordUserCreateOrConnectWithoutNotionAuthInput>
    createMany?: DiscordUserCreateManyNotionAuthInputEnvelope
    connect?: Enumerable<DiscordUserWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutNotionAuthInput = {
    create?: XOR<UserCreateWithoutNotionAuthInput, UserUncheckedCreateWithoutNotionAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotionAuthInput
    upsert?: UserUpsertWithoutNotionAuthInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotionAuthInput, UserUncheckedUpdateWithoutNotionAuthInput>
  }

  export type DiscordUserUpdateManyWithoutNotionAuthInput = {
    create?: XOR<Enumerable<DiscordUserCreateWithoutNotionAuthInput>, Enumerable<DiscordUserUncheckedCreateWithoutNotionAuthInput>>
    connectOrCreate?: Enumerable<DiscordUserCreateOrConnectWithoutNotionAuthInput>
    upsert?: Enumerable<DiscordUserUpsertWithWhereUniqueWithoutNotionAuthInput>
    createMany?: DiscordUserCreateManyNotionAuthInputEnvelope
    set?: Enumerable<DiscordUserWhereUniqueInput>
    disconnect?: Enumerable<DiscordUserWhereUniqueInput>
    delete?: Enumerable<DiscordUserWhereUniqueInput>
    connect?: Enumerable<DiscordUserWhereUniqueInput>
    update?: Enumerable<DiscordUserUpdateWithWhereUniqueWithoutNotionAuthInput>
    updateMany?: Enumerable<DiscordUserUpdateManyWithWhereWithoutNotionAuthInput>
    deleteMany?: Enumerable<DiscordUserScalarWhereInput>
  }

  export type DiscordUserUncheckedUpdateManyWithoutNotionAuthInput = {
    create?: XOR<Enumerable<DiscordUserCreateWithoutNotionAuthInput>, Enumerable<DiscordUserUncheckedCreateWithoutNotionAuthInput>>
    connectOrCreate?: Enumerable<DiscordUserCreateOrConnectWithoutNotionAuthInput>
    upsert?: Enumerable<DiscordUserUpsertWithWhereUniqueWithoutNotionAuthInput>
    createMany?: DiscordUserCreateManyNotionAuthInputEnvelope
    set?: Enumerable<DiscordUserWhereUniqueInput>
    disconnect?: Enumerable<DiscordUserWhereUniqueInput>
    delete?: Enumerable<DiscordUserWhereUniqueInput>
    connect?: Enumerable<DiscordUserWhereUniqueInput>
    update?: Enumerable<DiscordUserUpdateWithWhereUniqueWithoutNotionAuthInput>
    updateMany?: Enumerable<DiscordUserUpdateManyWithWhereWithoutNotionAuthInput>
    deleteMany?: Enumerable<DiscordUserScalarWhereInput>
  }

  export type DiscordMessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<DiscordMessageCreateWithoutThreadInput>, Enumerable<DiscordMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<DiscordMessageCreateOrConnectWithoutThreadInput>
    createMany?: DiscordMessageCreateManyThreadInputEnvelope
    connect?: Enumerable<DiscordMessageWhereUniqueInput>
  }

  export type DiscordMessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<DiscordMessageCreateWithoutThreadInput>, Enumerable<DiscordMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<DiscordMessageCreateOrConnectWithoutThreadInput>
    createMany?: DiscordMessageCreateManyThreadInputEnvelope
    connect?: Enumerable<DiscordMessageWhereUniqueInput>
  }

  export type DiscordMessageUpdateManyWithoutThreadInput = {
    create?: XOR<Enumerable<DiscordMessageCreateWithoutThreadInput>, Enumerable<DiscordMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<DiscordMessageCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<DiscordMessageUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: DiscordMessageCreateManyThreadInputEnvelope
    set?: Enumerable<DiscordMessageWhereUniqueInput>
    disconnect?: Enumerable<DiscordMessageWhereUniqueInput>
    delete?: Enumerable<DiscordMessageWhereUniqueInput>
    connect?: Enumerable<DiscordMessageWhereUniqueInput>
    update?: Enumerable<DiscordMessageUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<DiscordMessageUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<DiscordMessageScalarWhereInput>
  }

  export type DiscordMessageUncheckedUpdateManyWithoutThreadInput = {
    create?: XOR<Enumerable<DiscordMessageCreateWithoutThreadInput>, Enumerable<DiscordMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<DiscordMessageCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<DiscordMessageUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: DiscordMessageCreateManyThreadInputEnvelope
    set?: Enumerable<DiscordMessageWhereUniqueInput>
    disconnect?: Enumerable<DiscordMessageWhereUniqueInput>
    delete?: Enumerable<DiscordMessageWhereUniqueInput>
    connect?: Enumerable<DiscordMessageWhereUniqueInput>
    update?: Enumerable<DiscordMessageUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<DiscordMessageUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<DiscordMessageScalarWhereInput>
  }

  export type FeatureCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureCreateWithoutUserInput>, Enumerable<FeatureUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureCreateOrConnectWithoutUserInput>
    createMany?: FeatureCreateManyUserInputEnvelope
    connect?: Enumerable<FeatureWhereUniqueInput>
  }

  export type FeatureRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureRequestCreateWithoutUserInput>, Enumerable<FeatureRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureRequestCreateOrConnectWithoutUserInput>
    createMany?: FeatureRequestCreateManyUserInputEnvelope
    connect?: Enumerable<FeatureRequestWhereUniqueInput>
  }

  export type NotionAuthCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotionAuthCreateWithoutUserInput>, Enumerable<NotionAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotionAuthCreateOrConnectWithoutUserInput>
    createMany?: NotionAuthCreateManyUserInputEnvelope
    connect?: Enumerable<NotionAuthWhereUniqueInput>
  }

  export type FeatureUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureCreateWithoutUserInput>, Enumerable<FeatureUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureCreateOrConnectWithoutUserInput>
    createMany?: FeatureCreateManyUserInputEnvelope
    connect?: Enumerable<FeatureWhereUniqueInput>
  }

  export type FeatureRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureRequestCreateWithoutUserInput>, Enumerable<FeatureRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureRequestCreateOrConnectWithoutUserInput>
    createMany?: FeatureRequestCreateManyUserInputEnvelope
    connect?: Enumerable<FeatureRequestWhereUniqueInput>
  }

  export type NotionAuthUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotionAuthCreateWithoutUserInput>, Enumerable<NotionAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotionAuthCreateOrConnectWithoutUserInput>
    createMany?: NotionAuthCreateManyUserInputEnvelope
    connect?: Enumerable<NotionAuthWhereUniqueInput>
  }

  export type FeatureUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureCreateWithoutUserInput>, Enumerable<FeatureUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FeatureUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FeatureCreateManyUserInputEnvelope
    set?: Enumerable<FeatureWhereUniqueInput>
    disconnect?: Enumerable<FeatureWhereUniqueInput>
    delete?: Enumerable<FeatureWhereUniqueInput>
    connect?: Enumerable<FeatureWhereUniqueInput>
    update?: Enumerable<FeatureUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FeatureUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FeatureScalarWhereInput>
  }

  export type FeatureRequestUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureRequestCreateWithoutUserInput>, Enumerable<FeatureRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FeatureRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FeatureRequestCreateManyUserInputEnvelope
    set?: Enumerable<FeatureRequestWhereUniqueInput>
    disconnect?: Enumerable<FeatureRequestWhereUniqueInput>
    delete?: Enumerable<FeatureRequestWhereUniqueInput>
    connect?: Enumerable<FeatureRequestWhereUniqueInput>
    update?: Enumerable<FeatureRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FeatureRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FeatureRequestScalarWhereInput>
  }

  export type NotionAuthUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotionAuthCreateWithoutUserInput>, Enumerable<NotionAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotionAuthCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotionAuthUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotionAuthCreateManyUserInputEnvelope
    set?: Enumerable<NotionAuthWhereUniqueInput>
    disconnect?: Enumerable<NotionAuthWhereUniqueInput>
    delete?: Enumerable<NotionAuthWhereUniqueInput>
    connect?: Enumerable<NotionAuthWhereUniqueInput>
    update?: Enumerable<NotionAuthUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotionAuthUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotionAuthScalarWhereInput>
  }

  export type FeatureUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureCreateWithoutUserInput>, Enumerable<FeatureUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FeatureUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FeatureCreateManyUserInputEnvelope
    set?: Enumerable<FeatureWhereUniqueInput>
    disconnect?: Enumerable<FeatureWhereUniqueInput>
    delete?: Enumerable<FeatureWhereUniqueInput>
    connect?: Enumerable<FeatureWhereUniqueInput>
    update?: Enumerable<FeatureUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FeatureUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FeatureScalarWhereInput>
  }

  export type FeatureRequestUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<FeatureRequestCreateWithoutUserInput>, Enumerable<FeatureRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FeatureRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FeatureRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FeatureRequestCreateManyUserInputEnvelope
    set?: Enumerable<FeatureRequestWhereUniqueInput>
    disconnect?: Enumerable<FeatureRequestWhereUniqueInput>
    delete?: Enumerable<FeatureRequestWhereUniqueInput>
    connect?: Enumerable<FeatureRequestWhereUniqueInput>
    update?: Enumerable<FeatureRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FeatureRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FeatureRequestScalarWhereInput>
  }

  export type NotionAuthUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotionAuthCreateWithoutUserInput>, Enumerable<NotionAuthUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotionAuthCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotionAuthUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotionAuthCreateManyUserInputEnvelope
    set?: Enumerable<NotionAuthWhereUniqueInput>
    disconnect?: Enumerable<NotionAuthWhereUniqueInput>
    delete?: Enumerable<NotionAuthWhereUniqueInput>
    connect?: Enumerable<NotionAuthWhereUniqueInput>
    update?: Enumerable<NotionAuthUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotionAuthUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotionAuthScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ThreadCreateWithoutDiscordMessageInput = {
    ticketNumber: string
    threadName: string
    createdTime: string
    threadLink: string
    bugOverview: string
  }

  export type ThreadUncheckedCreateWithoutDiscordMessageInput = {
    ticketNumber: string
    threadName: string
    createdTime: string
    threadLink: string
    bugOverview: string
  }

  export type ThreadCreateOrConnectWithoutDiscordMessageInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutDiscordMessageInput, ThreadUncheckedCreateWithoutDiscordMessageInput>
  }

  export type ThreadUpsertWithoutDiscordMessageInput = {
    update: XOR<ThreadUpdateWithoutDiscordMessageInput, ThreadUncheckedUpdateWithoutDiscordMessageInput>
    create: XOR<ThreadCreateWithoutDiscordMessageInput, ThreadUncheckedCreateWithoutDiscordMessageInput>
  }

  export type ThreadUpdateWithoutDiscordMessageInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    threadName?: StringFieldUpdateOperationsInput | string
    createdTime?: StringFieldUpdateOperationsInput | string
    threadLink?: StringFieldUpdateOperationsInput | string
    bugOverview?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadUncheckedUpdateWithoutDiscordMessageInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    threadName?: StringFieldUpdateOperationsInput | string
    createdTime?: StringFieldUpdateOperationsInput | string
    threadLink?: StringFieldUpdateOperationsInput | string
    bugOverview?: StringFieldUpdateOperationsInput | string
  }

  export type NotionAuthCreateWithoutDiscordUserInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    guildName?: string | null
    User: UserCreateNestedOneWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedCreateWithoutDiscordUserInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    userId: string
    guildName?: string | null
  }

  export type NotionAuthCreateOrConnectWithoutDiscordUserInput = {
    where: NotionAuthWhereUniqueInput
    create: XOR<NotionAuthCreateWithoutDiscordUserInput, NotionAuthUncheckedCreateWithoutDiscordUserInput>
  }

  export type NotionAuthUpsertWithoutDiscordUserInput = {
    update: XOR<NotionAuthUpdateWithoutDiscordUserInput, NotionAuthUncheckedUpdateWithoutDiscordUserInput>
    create: XOR<NotionAuthCreateWithoutDiscordUserInput, NotionAuthUncheckedCreateWithoutDiscordUserInput>
  }

  export type NotionAuthUpdateWithoutDiscordUserInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedUpdateWithoutDiscordUserInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutFeatureInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    FeatureRequest?: FeatureRequestCreateNestedManyWithoutUserInput
    NotionAuth?: NotionAuthCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeatureInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    FeatureRequest?: FeatureRequestUncheckedCreateNestedManyWithoutUserInput
    NotionAuth?: NotionAuthUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeatureInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeatureInput, UserUncheckedCreateWithoutFeatureInput>
  }

  export type FeatureRequestMapCreateWithoutFeatureInput = {
    pinned?: boolean
    cluster?: number
    FeatureRequest: FeatureRequestCreateNestedOneWithoutFeatureRequestMapInput
  }

  export type FeatureRequestMapUncheckedCreateWithoutFeatureInput = {
    featureRequestId: string
    pinned?: boolean
    cluster?: number
  }

  export type FeatureRequestMapCreateOrConnectWithoutFeatureInput = {
    where: FeatureRequestMapWhereUniqueInput
    create: XOR<FeatureRequestMapCreateWithoutFeatureInput, FeatureRequestMapUncheckedCreateWithoutFeatureInput>
  }

  export type FeatureRequestMapCreateManyFeatureInputEnvelope = {
    data: Enumerable<FeatureRequestMapCreateManyFeatureInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFeatureInput = {
    update: XOR<UserUpdateWithoutFeatureInput, UserUncheckedUpdateWithoutFeatureInput>
    create: XOR<UserCreateWithoutFeatureInput, UserUncheckedCreateWithoutFeatureInput>
  }

  export type UserUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    FeatureRequest?: FeatureRequestUpdateManyWithoutUserInput
    NotionAuth?: NotionAuthUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    FeatureRequest?: FeatureRequestUncheckedUpdateManyWithoutUserInput
    NotionAuth?: NotionAuthUncheckedUpdateManyWithoutUserInput
  }

  export type FeatureRequestMapUpsertWithWhereUniqueWithoutFeatureInput = {
    where: FeatureRequestMapWhereUniqueInput
    update: XOR<FeatureRequestMapUpdateWithoutFeatureInput, FeatureRequestMapUncheckedUpdateWithoutFeatureInput>
    create: XOR<FeatureRequestMapCreateWithoutFeatureInput, FeatureRequestMapUncheckedCreateWithoutFeatureInput>
  }

  export type FeatureRequestMapUpdateWithWhereUniqueWithoutFeatureInput = {
    where: FeatureRequestMapWhereUniqueInput
    data: XOR<FeatureRequestMapUpdateWithoutFeatureInput, FeatureRequestMapUncheckedUpdateWithoutFeatureInput>
  }

  export type FeatureRequestMapUpdateManyWithWhereWithoutFeatureInput = {
    where: FeatureRequestMapScalarWhereInput
    data: XOR<FeatureRequestMapUpdateManyMutationInput, FeatureRequestMapUncheckedUpdateManyWithoutFeatureRequestMapInput>
  }

  export type FeatureRequestMapScalarWhereInput = {
    AND?: Enumerable<FeatureRequestMapScalarWhereInput>
    OR?: Enumerable<FeatureRequestMapScalarWhereInput>
    NOT?: Enumerable<FeatureRequestMapScalarWhereInput>
    featureId?: IntFilter | number
    featureRequestId?: StringFilter | string
    pinned?: BoolFilter | boolean
    cluster?: IntFilter | number
  }

  export type UserCreateWithoutFeatureRequestInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    Feature?: FeatureCreateNestedManyWithoutUserInput
    NotionAuth?: NotionAuthCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeatureRequestInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    Feature?: FeatureUncheckedCreateNestedManyWithoutUserInput
    NotionAuth?: NotionAuthUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeatureRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeatureRequestInput, UserUncheckedCreateWithoutFeatureRequestInput>
  }

  export type FeatureRequestMapCreateWithoutFeatureRequestInput = {
    pinned?: boolean
    cluster?: number
    Feature: FeatureCreateNestedOneWithoutFeatureRequestMapInput
  }

  export type FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput = {
    featureId: number
    pinned?: boolean
    cluster?: number
  }

  export type FeatureRequestMapCreateOrConnectWithoutFeatureRequestInput = {
    where: FeatureRequestMapWhereUniqueInput
    create: XOR<FeatureRequestMapCreateWithoutFeatureRequestInput, FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput>
  }

  export type FeatureRequestMapCreateManyFeatureRequestInputEnvelope = {
    data: Enumerable<FeatureRequestMapCreateManyFeatureRequestInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFeatureRequestInput = {
    update: XOR<UserUpdateWithoutFeatureRequestInput, UserUncheckedUpdateWithoutFeatureRequestInput>
    create: XOR<UserCreateWithoutFeatureRequestInput, UserUncheckedCreateWithoutFeatureRequestInput>
  }

  export type UserUpdateWithoutFeatureRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    Feature?: FeatureUpdateManyWithoutUserInput
    NotionAuth?: NotionAuthUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutFeatureRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    Feature?: FeatureUncheckedUpdateManyWithoutUserInput
    NotionAuth?: NotionAuthUncheckedUpdateManyWithoutUserInput
  }

  export type FeatureRequestMapUpsertWithWhereUniqueWithoutFeatureRequestInput = {
    where: FeatureRequestMapWhereUniqueInput
    update: XOR<FeatureRequestMapUpdateWithoutFeatureRequestInput, FeatureRequestMapUncheckedUpdateWithoutFeatureRequestInput>
    create: XOR<FeatureRequestMapCreateWithoutFeatureRequestInput, FeatureRequestMapUncheckedCreateWithoutFeatureRequestInput>
  }

  export type FeatureRequestMapUpdateWithWhereUniqueWithoutFeatureRequestInput = {
    where: FeatureRequestMapWhereUniqueInput
    data: XOR<FeatureRequestMapUpdateWithoutFeatureRequestInput, FeatureRequestMapUncheckedUpdateWithoutFeatureRequestInput>
  }

  export type FeatureRequestMapUpdateManyWithWhereWithoutFeatureRequestInput = {
    where: FeatureRequestMapScalarWhereInput
    data: XOR<FeatureRequestMapUpdateManyMutationInput, FeatureRequestMapUncheckedUpdateManyWithoutFeatureRequestMapInput>
  }

  export type FeatureCreateWithoutFeatureRequestMapInput = {
    title: string
    description?: string
    columnState: number
    rankState: number
    isSearched?: boolean
    User: UserCreateNestedOneWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutFeatureRequestMapInput = {
    id?: number
    title: string
    description?: string
    userId: string
    columnState: number
    rankState: number
    isSearched?: boolean
  }

  export type FeatureCreateOrConnectWithoutFeatureRequestMapInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutFeatureRequestMapInput, FeatureUncheckedCreateWithoutFeatureRequestMapInput>
  }

  export type FeatureRequestCreateWithoutFeatureRequestMapInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    User: UserCreateNestedOneWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedCreateWithoutFeatureRequestMapInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    userId: string
  }

  export type FeatureRequestCreateOrConnectWithoutFeatureRequestMapInput = {
    where: FeatureRequestWhereUniqueInput
    create: XOR<FeatureRequestCreateWithoutFeatureRequestMapInput, FeatureRequestUncheckedCreateWithoutFeatureRequestMapInput>
  }

  export type FeatureUpsertWithoutFeatureRequestMapInput = {
    update: XOR<FeatureUpdateWithoutFeatureRequestMapInput, FeatureUncheckedUpdateWithoutFeatureRequestMapInput>
    create: XOR<FeatureCreateWithoutFeatureRequestMapInput, FeatureUncheckedCreateWithoutFeatureRequestMapInput>
  }

  export type FeatureUpdateWithoutFeatureRequestMapInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutFeatureInput
  }

  export type FeatureUncheckedUpdateWithoutFeatureRequestMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureRequestUpsertWithoutFeatureRequestMapInput = {
    update: XOR<FeatureRequestUpdateWithoutFeatureRequestMapInput, FeatureRequestUncheckedUpdateWithoutFeatureRequestMapInput>
    create: XOR<FeatureRequestCreateWithoutFeatureRequestMapInput, FeatureRequestUncheckedCreateWithoutFeatureRequestMapInput>
  }

  export type FeatureRequestUpdateWithoutFeatureRequestMapInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedUpdateWithoutFeatureRequestMapInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutNotionAuthInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    Feature?: FeatureCreateNestedManyWithoutUserInput
    FeatureRequest?: FeatureRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotionAuthInput = {
    id: string
    email: string
    discordBotAuth?: boolean
    Feature?: FeatureUncheckedCreateNestedManyWithoutUserInput
    FeatureRequest?: FeatureRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotionAuthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotionAuthInput, UserUncheckedCreateWithoutNotionAuthInput>
  }

  export type DiscordUserCreateWithoutNotionAuthInput = {
    username: string
  }

  export type DiscordUserUncheckedCreateWithoutNotionAuthInput = {
    username: string
  }

  export type DiscordUserCreateOrConnectWithoutNotionAuthInput = {
    where: DiscordUserWhereUniqueInput
    create: XOR<DiscordUserCreateWithoutNotionAuthInput, DiscordUserUncheckedCreateWithoutNotionAuthInput>
  }

  export type DiscordUserCreateManyNotionAuthInputEnvelope = {
    data: Enumerable<DiscordUserCreateManyNotionAuthInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotionAuthInput = {
    update: XOR<UserUpdateWithoutNotionAuthInput, UserUncheckedUpdateWithoutNotionAuthInput>
    create: XOR<UserCreateWithoutNotionAuthInput, UserUncheckedCreateWithoutNotionAuthInput>
  }

  export type UserUpdateWithoutNotionAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    Feature?: FeatureUpdateManyWithoutUserInput
    FeatureRequest?: FeatureRequestUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNotionAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    discordBotAuth?: BoolFieldUpdateOperationsInput | boolean
    Feature?: FeatureUncheckedUpdateManyWithoutUserInput
    FeatureRequest?: FeatureRequestUncheckedUpdateManyWithoutUserInput
  }

  export type DiscordUserUpsertWithWhereUniqueWithoutNotionAuthInput = {
    where: DiscordUserWhereUniqueInput
    update: XOR<DiscordUserUpdateWithoutNotionAuthInput, DiscordUserUncheckedUpdateWithoutNotionAuthInput>
    create: XOR<DiscordUserCreateWithoutNotionAuthInput, DiscordUserUncheckedCreateWithoutNotionAuthInput>
  }

  export type DiscordUserUpdateWithWhereUniqueWithoutNotionAuthInput = {
    where: DiscordUserWhereUniqueInput
    data: XOR<DiscordUserUpdateWithoutNotionAuthInput, DiscordUserUncheckedUpdateWithoutNotionAuthInput>
  }

  export type DiscordUserUpdateManyWithWhereWithoutNotionAuthInput = {
    where: DiscordUserScalarWhereInput
    data: XOR<DiscordUserUpdateManyMutationInput, DiscordUserUncheckedUpdateManyWithoutDiscordUserInput>
  }

  export type DiscordUserScalarWhereInput = {
    AND?: Enumerable<DiscordUserScalarWhereInput>
    OR?: Enumerable<DiscordUserScalarWhereInput>
    NOT?: Enumerable<DiscordUserScalarWhereInput>
    username?: StringFilter | string
    notionAuthId?: StringFilter | string
  }

  export type DiscordMessageCreateWithoutThreadInput = {
    messageUser: string
    messageContent: string
  }

  export type DiscordMessageUncheckedCreateWithoutThreadInput = {
    id?: number
    messageUser: string
    messageContent: string
  }

  export type DiscordMessageCreateOrConnectWithoutThreadInput = {
    where: DiscordMessageWhereUniqueInput
    create: XOR<DiscordMessageCreateWithoutThreadInput, DiscordMessageUncheckedCreateWithoutThreadInput>
  }

  export type DiscordMessageCreateManyThreadInputEnvelope = {
    data: Enumerable<DiscordMessageCreateManyThreadInput>
    skipDuplicates?: boolean
  }

  export type DiscordMessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: DiscordMessageWhereUniqueInput
    update: XOR<DiscordMessageUpdateWithoutThreadInput, DiscordMessageUncheckedUpdateWithoutThreadInput>
    create: XOR<DiscordMessageCreateWithoutThreadInput, DiscordMessageUncheckedCreateWithoutThreadInput>
  }

  export type DiscordMessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: DiscordMessageWhereUniqueInput
    data: XOR<DiscordMessageUpdateWithoutThreadInput, DiscordMessageUncheckedUpdateWithoutThreadInput>
  }

  export type DiscordMessageUpdateManyWithWhereWithoutThreadInput = {
    where: DiscordMessageScalarWhereInput
    data: XOR<DiscordMessageUpdateManyMutationInput, DiscordMessageUncheckedUpdateManyWithoutDiscordMessageInput>
  }

  export type DiscordMessageScalarWhereInput = {
    AND?: Enumerable<DiscordMessageScalarWhereInput>
    OR?: Enumerable<DiscordMessageScalarWhereInput>
    NOT?: Enumerable<DiscordMessageScalarWhereInput>
    id?: IntFilter | number
    threadId?: StringFilter | string
    messageUser?: StringFilter | string
    messageContent?: StringFilter | string
  }

  export type FeatureCreateWithoutUserInput = {
    title: string
    description?: string
    columnState: number
    rankState: number
    isSearched?: boolean
    FeatureRequestMap?: FeatureRequestMapCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    description?: string
    columnState: number
    rankState: number
    isSearched?: boolean
    FeatureRequestMap?: FeatureRequestMapUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutUserInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutUserInput, FeatureUncheckedCreateWithoutUserInput>
  }

  export type FeatureCreateManyUserInputEnvelope = {
    data: Enumerable<FeatureCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FeatureRequestCreateWithoutUserInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    FeatureRequestMap?: FeatureRequestMapCreateNestedManyWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedCreateWithoutUserInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
    FeatureRequestMap?: FeatureRequestMapUncheckedCreateNestedManyWithoutFeatureRequestInput
  }

  export type FeatureRequestCreateOrConnectWithoutUserInput = {
    where: FeatureRequestWhereUniqueInput
    create: XOR<FeatureRequestCreateWithoutUserInput, FeatureRequestUncheckedCreateWithoutUserInput>
  }

  export type FeatureRequestCreateManyUserInputEnvelope = {
    data: Enumerable<FeatureRequestCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NotionAuthCreateWithoutUserInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    guildName?: string | null
    DiscordUser?: DiscordUserCreateNestedManyWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedCreateWithoutUserInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    guildName?: string | null
    DiscordUser?: DiscordUserUncheckedCreateNestedManyWithoutNotionAuthInput
  }

  export type NotionAuthCreateOrConnectWithoutUserInput = {
    where: NotionAuthWhereUniqueInput
    create: XOR<NotionAuthCreateWithoutUserInput, NotionAuthUncheckedCreateWithoutUserInput>
  }

  export type NotionAuthCreateManyUserInputEnvelope = {
    data: Enumerable<NotionAuthCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FeatureUpsertWithWhereUniqueWithoutUserInput = {
    where: FeatureWhereUniqueInput
    update: XOR<FeatureUpdateWithoutUserInput, FeatureUncheckedUpdateWithoutUserInput>
    create: XOR<FeatureCreateWithoutUserInput, FeatureUncheckedCreateWithoutUserInput>
  }

  export type FeatureUpdateWithWhereUniqueWithoutUserInput = {
    where: FeatureWhereUniqueInput
    data: XOR<FeatureUpdateWithoutUserInput, FeatureUncheckedUpdateWithoutUserInput>
  }

  export type FeatureUpdateManyWithWhereWithoutUserInput = {
    where: FeatureScalarWhereInput
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type FeatureScalarWhereInput = {
    AND?: Enumerable<FeatureScalarWhereInput>
    OR?: Enumerable<FeatureScalarWhereInput>
    NOT?: Enumerable<FeatureScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    userId?: StringFilter | string
    columnState?: IntFilter | number
    rankState?: IntFilter | number
    isSearched?: BoolFilter | boolean
  }

  export type FeatureRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: FeatureRequestWhereUniqueInput
    update: XOR<FeatureRequestUpdateWithoutUserInput, FeatureRequestUncheckedUpdateWithoutUserInput>
    create: XOR<FeatureRequestCreateWithoutUserInput, FeatureRequestUncheckedCreateWithoutUserInput>
  }

  export type FeatureRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: FeatureRequestWhereUniqueInput
    data: XOR<FeatureRequestUpdateWithoutUserInput, FeatureRequestUncheckedUpdateWithoutUserInput>
  }

  export type FeatureRequestUpdateManyWithWhereWithoutUserInput = {
    where: FeatureRequestScalarWhereInput
    data: XOR<FeatureRequestUpdateManyMutationInput, FeatureRequestUncheckedUpdateManyWithoutFeatureRequestInput>
  }

  export type FeatureRequestScalarWhereInput = {
    AND?: Enumerable<FeatureRequestScalarWhereInput>
    OR?: Enumerable<FeatureRequestScalarWhereInput>
    NOT?: Enumerable<FeatureRequestScalarWhereInput>
    fr_id?: StringFilter | string
    message_id?: StringFilter | string
    message?: StringFilter | string
    created_at?: StringFilter | string
    author?: StringFilter | string
    label?: StringFilter | string
    fr?: StringFilter | string
    kmeans_labels?: IntFilter | number
    userId?: StringFilter | string
  }

  export type NotionAuthUpsertWithWhereUniqueWithoutUserInput = {
    where: NotionAuthWhereUniqueInput
    update: XOR<NotionAuthUpdateWithoutUserInput, NotionAuthUncheckedUpdateWithoutUserInput>
    create: XOR<NotionAuthCreateWithoutUserInput, NotionAuthUncheckedCreateWithoutUserInput>
  }

  export type NotionAuthUpdateWithWhereUniqueWithoutUserInput = {
    where: NotionAuthWhereUniqueInput
    data: XOR<NotionAuthUpdateWithoutUserInput, NotionAuthUncheckedUpdateWithoutUserInput>
  }

  export type NotionAuthUpdateManyWithWhereWithoutUserInput = {
    where: NotionAuthScalarWhereInput
    data: XOR<NotionAuthUpdateManyMutationInput, NotionAuthUncheckedUpdateManyWithoutNotionAuthInput>
  }

  export type NotionAuthScalarWhereInput = {
    AND?: Enumerable<NotionAuthScalarWhereInput>
    OR?: Enumerable<NotionAuthScalarWhereInput>
    NOT?: Enumerable<NotionAuthScalarWhereInput>
    botId?: StringFilter | string
    accessToken?: StringFilter | string
    owner?: StringFilter | string
    duplicatedTemplateId?: StringFilter | string
    workspaceIcon?: StringFilter | string
    workspaceId?: StringFilter | string
    workspaceName?: StringFilter | string
    userId?: StringFilter | string
    guildName?: StringNullableFilter | string | null
  }

  export type FeatureRequestMapCreateManyFeatureInput = {
    featureRequestId: string
    pinned?: boolean
    cluster?: number
  }

  export type FeatureRequestMapUpdateWithoutFeatureInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
    FeatureRequest?: FeatureRequestUpdateOneRequiredWithoutFeatureRequestMapInput
  }

  export type FeatureRequestMapUncheckedUpdateWithoutFeatureInput = {
    featureRequestId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
  }

  export type FeatureRequestMapUncheckedUpdateManyWithoutFeatureRequestMapInput = {
    featureRequestId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
  }

  export type FeatureRequestMapCreateManyFeatureRequestInput = {
    featureId: number
    pinned?: boolean
    cluster?: number
  }

  export type FeatureRequestMapUpdateWithoutFeatureRequestInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
    Feature?: FeatureUpdateOneRequiredWithoutFeatureRequestMapInput
  }

  export type FeatureRequestMapUncheckedUpdateWithoutFeatureRequestInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    cluster?: IntFieldUpdateOperationsInput | number
  }

  export type DiscordUserCreateManyNotionAuthInput = {
    username: string
  }

  export type DiscordUserUpdateWithoutNotionAuthInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordUserUncheckedUpdateWithoutNotionAuthInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordUserUncheckedUpdateManyWithoutDiscordUserInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordMessageCreateManyThreadInput = {
    id?: number
    messageUser: string
    messageContent: string
  }

  export type DiscordMessageUpdateWithoutThreadInput = {
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordMessageUncheckedUpdateWithoutThreadInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
  }

  export type DiscordMessageUncheckedUpdateManyWithoutDiscordMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageUser?: StringFieldUpdateOperationsInput | string
    messageContent?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureCreateManyUserInput = {
    id?: number
    title: string
    description?: string
    columnState: number
    rankState: number
    isSearched?: boolean
  }

  export type FeatureRequestCreateManyUserInput = {
    fr_id: string
    message_id: string
    message: string
    created_at: string
    author: string
    label: string
    fr: string
    kmeans_labels: number
  }

  export type NotionAuthCreateManyUserInput = {
    botId: string
    accessToken: string
    owner: string
    duplicatedTemplateId: string
    workspaceIcon: string
    workspaceId: string
    workspaceName: string
    guildName?: string | null
  }

  export type FeatureUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
    FeatureRequestMap?: FeatureRequestMapUpdateManyWithoutFeatureInput
  }

  export type FeatureUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
    FeatureRequestMap?: FeatureRequestMapUncheckedUpdateManyWithoutFeatureInput
  }

  export type FeatureUncheckedUpdateManyWithoutFeatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    columnState?: IntFieldUpdateOperationsInput | number
    rankState?: IntFieldUpdateOperationsInput | number
    isSearched?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureRequestUpdateWithoutUserInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    FeatureRequestMap?: FeatureRequestMapUpdateManyWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedUpdateWithoutUserInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
    FeatureRequestMap?: FeatureRequestMapUncheckedUpdateManyWithoutFeatureRequestInput
  }

  export type FeatureRequestUncheckedUpdateManyWithoutFeatureRequestInput = {
    fr_id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    fr?: StringFieldUpdateOperationsInput | string
    kmeans_labels?: IntFieldUpdateOperationsInput | number
  }

  export type NotionAuthUpdateWithoutUserInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
    DiscordUser?: DiscordUserUpdateManyWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedUpdateWithoutUserInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
    DiscordUser?: DiscordUserUncheckedUpdateManyWithoutNotionAuthInput
  }

  export type NotionAuthUncheckedUpdateManyWithoutNotionAuthInput = {
    botId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    duplicatedTemplateId?: StringFieldUpdateOperationsInput | string
    workspaceIcon?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    workspaceName?: StringFieldUpdateOperationsInput | string
    guildName?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}